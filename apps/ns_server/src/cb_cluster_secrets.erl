%% @author Couchbase <info@couchbase.com>
%% @copyright 2024-Present Couchbase, Inc.
%%
%% Use of this software is governed by the Business Source License included in
%% the file licenses/BSL-Couchbase.txt.  As of the Change Date specified in that
%% file, in accordance with the Business Source License, use of this software
%% will be governed by the Apache License, Version 2.0, included in the file
%% licenses/APL2.txt.
%%
-module(cb_cluster_secrets).

-behaviour(gen_server).

-include("ns_common.hrl").
-include_lib("ns_common/include/cut.hrl").
-include("cb_cluster_secrets.hrl").
-ifdef(TEST).
-include_lib("eunit/include/eunit.hrl").
-endif.

%% gen_server callbacks
-export([init/1, handle_call/3, handle_cast/2, handle_info/2,
         terminate/2]).

-record(node_monitor, {}).
-record(master_monitor, {}).

%% API
-export([start_link_node_monitor/0,
         start_link_master_monitor/0,
         add_new_secret/1,
         replace_secret/2,
         get_all/0,
         get_secret/1,
         get_secret/2]).

-define(MASTER_MONITOR, {via, leader_registry, cb_cluster_secrets_master}).

-type secret_props() ::
    #{id := secret_id(),
      name := string(),
      creation_time := calendar:datetime(),
      type := secret_type(),
      usage := [{bucket_encryption, BucketName :: string()}],
      data := autogenerated_key_data()}.
-type secret_type() :: ?GENERATED_KEY_TYPE.
-type autogenerated_key_data() :: #{auto_rotation := boolean(),
                                    rotation_interval := pos_integer(),
                                    first_rotation_time := calendar:datetime(),
                                    active_key_id := kek_id(),
                                    keys := [kek_props()]}.
-type kek_props() :: #{id := kek_id(),
                       creation_time := calendar:datetime(),
                       key := {sensitive | encrypted_binary, binary()}}.
-type secret_id() :: non_neg_integer().
-type kek_id() :: uuid().
-type chronicle_snapshot() :: direct | map().
-type uuid() :: binary(). %% uuid as binary string

%%%===================================================================
%%% API
%%%===================================================================

%% Starts on each cluster node
-spec start_link_node_monitor() -> {ok, pid()}.
start_link_node_monitor() ->
    gen_server:start_link({local, ?MODULE}, ?MODULE, [node_monitor], []).

%% Starts on the master node only
-spec start_link_master_monitor() -> {ok, pid()}.
start_link_master_monitor() ->
    misc:start_singleton(gen_server, start_link,
                         [?MASTER_MONITOR, ?MODULE, [master_monitor], []]).

-spec get_all() -> [secret_props()].
get_all() -> get_all(direct).

-spec get_all(chronicle_snapshot()) -> [secret_props()].
get_all(Snapshot) ->
    chronicle_compat:get(Snapshot, ?CHRONICLE_SECRETS_KEY, #{default => []}).

-spec get_secret(secret_id()) -> {ok, secret_props()} | {error, not_found}.
get_secret(SecretId) -> get_secret(SecretId, direct).

-spec get_secret(secret_id(), chronicle_snapshot()) ->
                                    {ok, secret_props()} | {error, not_found}.
get_secret(SecretId, Snapshot) when is_integer(SecretId) ->
    SearchFun = fun (#{id := Id}) -> SecretId == Id end,
    case lists:search(SearchFun, get_all(Snapshot)) of
        {value, Props} ->
            {ok, Props};
        false ->
            {error, not_found}
    end.

-spec add_new_secret(secret_props()) -> {ok, secret_props()} | {error, _}.
add_new_secret(Props) ->
    CurrentDateTime = erlang:universaltime(),
    PropsWTime = Props#{creation_time => CurrentDateTime},
    RV = chronicle_kv:transaction(
           kv, [?CHRONICLE_SECRETS_KEY, ?CHRONICLE_NEXT_ID_KEY],
           fun (Snapshot) ->
               CurList = get_all(Snapshot),
               NextId = chronicle_compat:get(Snapshot, ?CHRONICLE_NEXT_ID_KEY,
                                             #{default => 0}),
               PropsWId = PropsWTime#{id => NextId},
               case prepare_new_secret(PropsWId) of
                   {ok, FinalProps} ->
                       NewList = [FinalProps | CurList],
                       {commit, [{set, ?CHRONICLE_SECRETS_KEY, NewList},
                                 {set, ?CHRONICLE_NEXT_ID_KEY, NextId + 1}],
                        FinalProps};
                   {error, Reason} ->
                       {abort, {error, Reason}}
               end
            end),
    case RV of
        {ok, _, Res} -> {ok, Res};
        {error, _} = Error -> Error
    end.

-spec replace_secret(secret_props(), map()) ->
                                    {ok, secret_props()} | {error, not_found}.
replace_secret(OldProps, NewProps) ->
    Props = copy_static_props(OldProps, NewProps),
    Res =
        chronicle_kv:transaction(
          kv, [?CHRONICLE_SECRETS_KEY],
          fun (Snapshot) ->
              CurList = get_all(Snapshot),
              case replace_secret_in_list(Props, CurList) of
                  false -> %% already removed, we should not create new
                      {abort, missing};
                  NewList ->
                      {commit, [{set, ?CHRONICLE_SECRETS_KEY, NewList}]}
              end
           end),
    case Res of
        {ok, _} -> {ok, Props};
        missing -> {error, not_found}
    end.

%% Cipher should have type crypto:cipher() but it is not exported
-spec generate_raw_key(Cipher :: atom()) -> binary().
generate_raw_key(Cipher) ->
    #{key_length := Length} = crypto:cipher_info(Cipher),
    crypto:strong_rand_bytes(Length).

%%%===================================================================
%%% gen_server callbacks
%%%===================================================================

init([Type]) ->
    EventFilter =
        fun (?CHRONICLE_SECRETS_KEY) -> true;
            (_Key) -> false
        end,
    Self = self(),
    chronicle_compat_events:subscribe(
      EventFilter, fun (Key) -> Self ! {config_change, Key} end),
    State = case Type of
                master_monitor ->
                    #master_monitor{};
                node_monitor ->
                    #node_monitor{}
            end,
    {ok, State}.

handle_call(Request, _From, State) ->
    ?log_warning("Unhandled call: ~p", [Request]),
    {noreply, State}.

handle_cast(Msg, State) ->
    ?log_warning("Unhandled cast: ~p", [Msg]),
    {noreply, State}.

handle_info({config_change, _}, State) ->
    {noreply, State};

handle_info(Info, State) ->
    ?log_warning("Unhandled info: ~p", [Info]),
    {noreply, State}.

terminate(_Reason, _State) ->
    ok.

%%%===================================================================
%%% Internal functions
%%%===================================================================

-spec generate_key(Creation :: calendar:datetime(), secret_props()) ->
                                            {ok, kek_props()} | {error, _}.
generate_key(CreationDateTime, SecretProps) ->
    Key = generate_raw_key(?ENVELOP_CIPHER),
    {ok, EncryptedKey} = maybe_encrypt_key(Key, SecretProps),
    {ok, #{id => misc:uuid_v4(),
           creation_time => CreationDateTime,
           key => EncryptedKey}}.

-spec set_active_key_in_props(secret_props(), kek_id()) -> secret_props().
set_active_key_in_props(#{type := ?GENERATED_KEY_TYPE,
                          data := Data} = SecretProps,
                        KeyId) ->
    SecretProps#{data => Data#{active_key_id => KeyId}}.

-spec set_keys_in_props(secret_props(), [kek_props()]) -> secret_props().
set_keys_in_props(#{type := ?GENERATED_KEY_TYPE, data := Data} = SecretProps,
                  Keys) ->
    SecretProps#{data => Data#{keys => Keys}}.

-spec copy_static_props(secret_props(), secret_props()) -> secret_props().
%% Copies properties that secret can never change
copy_static_props(#{type := Type, id := Id,
                    creation_time := CreationDT} = OldSecretProps,
                  #{type := Type} = NewSecretProps) ->
    NewSecretProps2 = NewSecretProps#{id => Id, creation_time => CreationDT},
    case NewSecretProps2 of
        #{type := ?GENERATED_KEY_TYPE} ->
            #{data := #{active_key_id := OldActiveId, keys := Keys}} =
                OldSecretProps,
            functools:chain(NewSecretProps2,
                            [set_keys_in_props(_, Keys),
                             set_active_key_in_props(_, OldActiveId)]);
        _ ->
            NewSecretProps2
    end.

-spec replace_secret_in_list(secret_props(), [secret_props()]) ->
                                                      [secret_props()] | false.
replace_secret_in_list(NewProps, List) ->
    Id = maps:get(id, NewProps),
    ReplaceFun = fun Replace([], _Acc) -> false;
                     Replace([Next | Rest], Acc) ->
                         case maps:get(id, Next) of
                             Id -> lists:reverse([NewProps | Acc], Rest);
                             _ -> Replace(Rest, [Next | Acc])
                         end
                 end,
    ReplaceFun(List, []).

-spec maybe_encrypt_key(binary(), secret_props()) ->
                           {ok, {sensitive, binary()}} | {error, _}.
maybe_encrypt_key(Key, #{type := ?GENERATED_KEY_TYPE}) ->
    %% Relying on SM to encrypt it automatically
    {ok, {sensitive, Key}}.

-spec prepare_new_secret(secret_props()) -> {ok, secret_props()} | {error, _}.
prepare_new_secret(#{type := ?GENERATED_KEY_TYPE,
                     creation_time := CurrentTime} = Props) ->
    maybe
        %% Creating new auto-generated key
        {ok, #{id := KekId} = KeyProps} ?= generate_key(CurrentTime,  Props),
        {ok, functools:chain(Props, [set_keys_in_props(_, [KeyProps]),
                                     set_active_key_in_props(_, KekId)])}
    else
        {error, _} = Error -> Error
    end;
prepare_new_secret(#{type := _Type}) ->
    {error, not_supported}.

-ifdef(TEST).
replace_secret_in_list_test() ->
    ?assertEqual(false, replace_secret_in_list(#{id => 3, p => 5}, [])),
    ?assertEqual(false,
                 replace_secret_in_list(#{id => 3, p => 5}, [#{id => 4}])),
    ?assertEqual([#{id => 4, p => 1}, #{id => 3, p => 5}, #{id => 1}],
                 replace_secret_in_list(
                   #{id => 3, p => 5},
                   [#{id => 4, p => 1}, #{id => 3, p => 6}, #{id => 1}])).
-endif.
