%% @author Couchbase <info@couchbase.com>
%% @copyright 2024-Present Couchbase, Inc.
%%
%% Use of this software is governed by the Business Source License included in
%% the file licenses/BSL-Couchbase.txt.  As of the Change Date specified in that
%% file, in accordance with the Business Source License, use of this software
%% will be governed by the Apache License, Version 2.0, included in the file
%% licenses/APL2.txt.
%%
-module(cb_cluster_secrets).

-behaviour(gen_server).

-include("ns_common.hrl").
-include_lib("ns_common/include/cut.hrl").
-include("cb_cluster_secrets.hrl").
-ifdef(TEST).
-include_lib("eunit/include/eunit.hrl").
-endif.

-define(MASTER_MONITOR_NAME, {via, leader_registry, cb_cluster_secrets_master}).
-define(RETRY_TIME, ?get_param(retry_time, 10000)).
-define(SYNC_TIMEOUT, ?get_timeout(sync, 60000)).
-define(NODE_PROC, node_monitor_process).
-define(MASTER_PROC, master_monitor_process).
-define(DEK_COUNTERS_UPDATE_TIMEOUT, ?get_timeout(counters_update, 30000)).
-define(DEK_TIMER_RETRY_TIME_S, ?get_param(dek_retry_interval, 60)).
-define(DEK_DROP_RETRY_TIME_S(Kind),
        ?get_param({dek_removal_min_interval, Kind}, 60*60*3)).

-ifndef(TEST).
-define(MIN_RECHECK_ROTATION_INTERVAL, ?get_param(min_rotation_recheck_interval,
                                                  1000)).
-define(MAX_RECHECK_ROTATION_INTERVAL, ?get_param(rotation_recheck_interval,
                                                  ?SECS_IN_DAY*1000)).
-else.
-define(MIN_RECHECK_ROTATION_INTERVAL, 1000).
-define(MAX_RECHECK_ROTATION_INTERVAL, ?SECS_IN_DAY*1000).
-endif.

%% API
-export([start_link_node_monitor/0,
         start_link_master_monitor/0,
         add_new_secret/1,
         replace_secret/2,
         delete_secret/1,
         get_all/0,
         get_secret/1,
         get_secret/2,
         get_active_key_id/1,
         get_active_key_id/2,
         rotate/1,
         get_secret_by_kek_id_map/1,
         ensure_can_encrypt_dek_kind/3,
         is_allowed_usage_for_secret/3,
         generate_raw_key/1,
         sync_with_all_node_monitors/0,
         new_key_id/0,
         is_valid_key_id/1,
         dek_drop_complete/1,
         is_name_unique/3]).

%% gen_server callbacks
-export([init/1, handle_call/3, handle_cast/2, handle_info/2,
         terminate/2]).

%% Can be called by other nodes:
-export([add_new_secret_internal/1,
         replace_secret_internal/2,
         rotate_internal/1,
         sync_with_node_monitor/0,
         delete_secret_internal/1,
         get_node_deks_info/0]).

-record(state, {proc_type :: ?NODE_PROC | ?MASTER_PROC,
                jobs :: [node_job()] | [master_job()],
                timers = #{retry_jobs => undefined,
                           rotate_keks => undefined,
                           dek_cleanup => undefined,
                           rotate_deks => undefined}
                         :: #{atom() := reference() | undefined},
                deks = #{} :: #{cb_deks:dek_kind() := deks_info()}}).

-export_type([secret_id/0, key_id/0, chronicle_snapshot/0]).

-type secret_props() ::
    #{id := secret_id(),
      name := string(),
      creation_time := calendar:datetime(),
      type := secret_type(),
      usage := [secret_usage()],
      data := autogenerated_key_data() | aws_key_data()}.
-type secret_type() :: ?GENERATED_KEY_TYPE | ?AWSKMS_KEY_TYPE.
-type secret_usage() :: {bucket_encryption, BucketName :: string()} |
                        secrets_encryption | config_encryption.
-type autogenerated_key_data() :: #{auto_rotation := boolean(),
                                    rotation_interval_in_days := pos_integer(),
                                    next_rotation_time := calendar:datetime(),
                                    last_rotation_time := calendar:datetime(),
                                    active_key_id := key_id(),
                                    keys := [kek_props()],
                                    encrypt_by := nodeSecretManager |
                                                  clusterSecret,
                                    encrypt_secret_id := secret_id() |
                                                         ?SECRET_ID_NOT_SET}.
-type kek_props() :: #{id := key_id(),
                       creation_time := calendar:datetime(),
                       key := {sensitive | encrypted_binary, binary()},
                       encrypted_by := undefined | {secret_id(), key_id()}}.
-type aws_key_data() :: #{key_arn := string(),
                          region := string(),
                          profile := string(),
                          config_file := string(),
                          credentials_file := string(),
                          use_imds := boolean(),
                          uuid := uuid()}.
-type secret_id() :: non_neg_integer().
-type key_id() :: uuid().
-type chronicle_snapshot() :: direct | map().
-type uuid() :: binary(). %% uuid as binary string
-type node_job() :: garbage_collect_keks |
                    {garbage_collect_deks, cb_deks:dek_kind()} |
                    ensure_all_keks_on_disk |
                    {maybe_update_deks, cb_deks:dek_kind()} |
                    maybe_reencrypt_deks |
                    {maybe_reencrypt_deks, cb_deks:dek_kind()}.

-type master_job() :: maybe_reencrypt_secrets | maybe_reset_deks_counters.

-type bad_encrypt_id() :: {encrypt_id, not_allowed | not_found}.
-type bad_usage_change() :: {usage, in_use}.

-type secret_in_use() :: {used_by, #{by_config := [cb_deks:dek_kind()],
                                     by_secret := [secret_id()],
                                     by_deks := [cb_deks:dek_kind()]}}.

-type deks_info() :: #{active_id := cb_deks:dek_id() | undefined,
                       deks := [cb_deks:dek()],
                       is_enabled := boolean(),
                       deks_being_dropped := [cb_deks:dek_id()],
                       last_drop_timestamp := undefined | non_neg_integer()}.

%%%===================================================================
%%% API
%%%===================================================================

%% Starts on each cluster node
-spec start_link_node_monitor() -> {ok, pid()}.
start_link_node_monitor() ->
    gen_server:start_link({local, ?MODULE}, ?MODULE, [?NODE_PROC], []).

%% Starts on the master node only
-spec start_link_master_monitor() -> {ok, pid()}.
start_link_master_monitor() ->
    misc:start_singleton(gen_server, start_link,
                         [?MASTER_MONITOR_NAME, ?MODULE, [?MASTER_PROC], []]).

-spec get_all() -> [secret_props()].
get_all() -> get_all(direct).

-spec get_all(chronicle_snapshot()) -> [secret_props()].
get_all(Snapshot) ->
    chronicle_compat:get(Snapshot, ?CHRONICLE_SECRETS_KEY, #{default => []}).

-spec get_secret(secret_id()) -> {ok, secret_props()} | {error, not_found}.
get_secret(SecretId) -> get_secret(SecretId, direct).

-spec get_secret(secret_id(), chronicle_snapshot()) ->
                                    {ok, secret_props()} | {error, not_found}.
get_secret(SecretId, Snapshot) when is_integer(SecretId) ->
    SearchFun = fun (#{id := Id}) -> SecretId == Id end,
    case lists:search(SearchFun, get_all(Snapshot)) of
        {value, Props} ->
            {ok, Props};
        false ->
            {error, not_found}
    end.

-spec add_new_secret(secret_props()) -> {ok, secret_props()} |
                                        {error, not_supported |
                                                bad_encrypt_id() |
                                                bad_usage_change()}.
add_new_secret(Props) ->
    execute_on_master({?MODULE, add_new_secret_internal, [Props]}).

-spec add_new_secret_internal(secret_props()) ->
                                            {ok, secret_props()} |
                                            {error, not_supported |
                                                    bad_encrypt_id() |
                                                    bad_usage_change()}.
add_new_secret_internal(Props) ->
    CurrentDateTime = erlang:universaltime(),
    PropsWTime = Props#{creation_time => CurrentDateTime},
    RV = chronicle_compat:txn(
           fun (Txn) ->
               Snapshot = fetch_snapshot_in_txn(Txn),
               CurList = get_all(Snapshot),
               NextId = chronicle_compat:get(Snapshot, ?CHRONICLE_NEXT_ID_KEY,
                                             #{default => 0}),
               PropsWId = PropsWTime#{id => NextId},
               maybe
                   {ok, FinalProps} ?= prepare_new_secret(PropsWId),
                   NewList = [FinalProps | CurList],
                   ok ?= validate_secret_in_txn(FinalProps, #{}, Snapshot),
                   {commit, [{set, ?CHRONICLE_SECRETS_KEY, NewList},
                             {set, ?CHRONICLE_NEXT_ID_KEY, NextId + 1}],
                    FinalProps}
               else
                   {error, Reason} -> {abort, {error, Reason}}
               end
            end),
    case RV of
        {ok, _, Res} ->
            sync_with_all_node_monitors(),
            {ok, Res};
        {error, _} = Error -> Error
    end.

-spec replace_secret(secret_props(), map()) ->
                                    {ok, secret_props()} |
                                    {error, not_found | bad_encrypt_id() |
                                            bad_usage_change()}.
replace_secret(OldProps, NewProps) ->
    execute_on_master({?MODULE, replace_secret_internal, [OldProps, NewProps]}).

-spec replace_secret_internal(secret_props(), map()) ->
                                    {ok, secret_props()} |
                                    {error, not_found | bad_encrypt_id() |
                                            bad_usage_change()}.
replace_secret_internal(OldProps, NewProps) ->
    %% Make sure we have most recent information about which secrets are in use
    %% This is needed for verification of 'usage' modification
    maybe_reset_deks_counters(),
    Props = copy_static_props(OldProps, NewProps),
    Res =
        chronicle_compat:txn(
          fun (Txn) ->
              Snapshot = fetch_snapshot_in_txn(Txn),
              CurList = get_all(Snapshot),
              case replace_secret_in_list(Props, CurList) of
                  false -> %% already removed, we should not create new
                      {abort, {error, not_found}};
                  NewList ->
                      case validate_secret_in_txn(Props, OldProps, Snapshot) of
                          ok ->
                              {commit,
                               [{set, ?CHRONICLE_SECRETS_KEY, NewList}]};
                          {error, _} = Error ->
                              {abort, Error}
                      end
              end
           end),
    case Res of
        {ok, _} ->
            sync_with_all_node_monitors(),
            {ok, Props};
        {error, _} = Error -> Error
    end.

-spec delete_secret(secret_id()) -> ok | {error, not_found | secret_in_use()}.
delete_secret(Id) ->
    execute_on_master({?MODULE, delete_secret_internal, [Id]}).

-spec delete_secret_internal(secret_id()) ->
          ok | {error, not_found | secret_in_use()}.
delete_secret_internal(Id) ->
    %% Make sure we have most recent information about which secrets are in use
    maybe_reset_deks_counters(),
    RV = chronicle_compat:txn(
           fun (Txn) ->
               maybe
                   Snapshot = fetch_snapshot_in_txn(Txn),
                   {ok, #{id := Id} = Props} ?= get_secret(Id, Snapshot),
                   ok ?= can_delete_secret(Props, Snapshot),
                   CurSecrets = get_all(Snapshot),
                   NewSecrets = lists:filter(
                                  fun (#{id := Id2}) -> Id2 /= Id end,
                                  CurSecrets),
                   true = (length(NewSecrets) + 1 == length(CurSecrets)),
                   {commit, [{set, ?CHRONICLE_SECRETS_KEY, NewSecrets}], Props}
               else
                   {error, Reason} -> {abort, Reason}
               end
           end),
    case RV of
        {ok, _, #{type := _Type} = _SecretProps} ->
            sync_with_all_node_monitors(),
            ok;
        not_found ->
            ok;
        {used_by, _} = Reason ->
            {error, Reason}
    end.

%% Cipher should have type crypto:cipher() but it is not exported
-spec generate_raw_key(Cipher :: atom()) -> binary().
generate_raw_key(Cipher) ->
    #{key_length := Length} = crypto:cipher_info(Cipher),
    crypto:strong_rand_bytes(Length).

-spec rotate(secret_id()) -> ok | {error, not_found | not_supported |
                                          bad_encrypt_id()}.
rotate(Id) ->
    execute_on_master({?MODULE, rotate_internal, [Id]}).

-spec rotate_internal(secret_id()) -> ok | {error, not_found |
                                                   not_supported |
                                                   bad_encrypt_id()}.
rotate_internal(Id) ->
    maybe
        {ok, #{type := ?GENERATED_KEY_TYPE} = SecretProps} ?= get_secret(Id),
        ?log_info("Rotating secret #~b", [Id]),
        {ok, NewKey} ?= generate_key(erlang:universaltime(), SecretProps),
        ok ?= add_active_key(Id, NewKey, _UpdateRotationTime = true),
        sync_with_all_node_monitors(),
        ok
    else
        {ok, #{}} ->
            ?log_info("Secret #~p rotation failed: not_supported", [Id]),
            {error, not_supported};
        {error, Reason} ->
            ?log_error("Secret #~p rotation failed: ~p", [Id, Reason]),
            {error, Reason}
    end.

-spec get_active_key_id(secret_id()) -> {ok, key_id()} |
                                        {error, not_found | not_supported}.
get_active_key_id(SecretId) ->
    get_active_key_id(SecretId, direct).

-spec get_active_key_id(secret_id(), chronicle_snapshot()) ->
                                            {ok, key_id()} |
                                            {error, not_found | not_supported}.
get_active_key_id(SecretId, Snapshot) ->
    maybe
        {ok, SecretProps} ?= get_secret(SecretId, Snapshot),
        {ok, _} ?= get_active_key_id_from_secret(SecretProps)
    else
        {error, _} = Err -> Err
    end.

-spec sync_with_node_monitor() -> ok.
sync_with_node_monitor() ->
    %% Mostly needed to make sure local cb_cluster_secret has pushed all new
    %% keys to disk before we try using them.
    %% chronicle_kv:sync() makes sure we have the latest chronicle data
    %% chronicle_compat_events:sync() makes sure all notifications has been sent
    %% sync([node()]) makes sure local cb_cluster_secret has handled that
    %% notification
    ok = chronicle_kv:sync(kv, ?SYNC_TIMEOUT),
    chronicle_compat_events:sync(),
    gen_server:call(?MODULE, sync, ?SYNC_TIMEOUT).

-spec ensure_can_encrypt_dek_kind(secret_id(), cb_deks:dek_kind(),
                                  chronicle_snapshot()) ->
          ok | {error, not_allowed | not_found}.
ensure_can_encrypt_dek_kind(SecretId, DekKind, Snapshot) ->
    maybe
        {ok, SecretProps} ?= get_secret(SecretId, Snapshot),
        true ?= can_secret_props_encrypt_dek_kind(SecretProps, DekKind),
        ok
    else
        false -> {error, not_allowed};
        {error, not_found} -> {error, not_found}
    end.

-spec is_allowed_usage_for_secret(secret_id(), secret_usage(),
                                  chronicle_snapshot()) ->
          ok | {error, not_allowed | not_found}.
is_allowed_usage_for_secret(SecretId, Usage, Snapshot) ->
    maybe
        {ok, #{usage := AllowedUsages}} ?= get_secret(SecretId, Snapshot),
        true ?= is_allowed([Usage], AllowedUsages),
        ok
    else
        false -> {error, not_allowed};
        {error, not_found} -> {error, not_found}
    end.

-spec get_secret_by_kek_id_map(chronicle_snapshot()) ->
                                                    #{key_id() := secret_id()}.
get_secret_by_kek_id_map(Snapshot) ->
    maps:from_list(lists:flatmap(
                     fun (#{id := Id} = S) ->
                         [{KeyId, Id} ||  KeyId <- get_all_keys_from_props(S)]
                     end, get_all(Snapshot))).

-spec get_node_deks_info() -> #{cb_deks:dek_kind() := [cb_deks:dek()]} | retry.
get_node_deks_info() ->
    gen_server:call(?MODULE, get_node_deks_info, ?DEK_COUNTERS_UPDATE_TIMEOUT).

-spec new_key_id() -> key_id().
new_key_id() ->
    Id = misc:uuid_v4(),
    true = is_valid_key_id(Id),
    Id.

-spec is_valid_key_id(binary()) -> boolean().
is_valid_key_id(Bin) -> misc:is_valid_v4uuid(Bin).

-spec dek_drop_complete(cb_deks:dek_kind()) -> ok.
dek_drop_complete(DekKind) ->
    ?MODULE ! {dek_drop_complete, DekKind},
    ok.

-spec is_name_unique(secret_id(), string(), chronicle_snapshot()) -> boolean().
is_name_unique(Id, Name, Snapshot) ->
    lists:all(fun (#{id := Id2}) when Id == Id2 -> true;
                  (#{name := Name2}) -> Name /= Name2
              end, get_all(Snapshot)).

%%%===================================================================
%%% gen_server callbacks
%%%===================================================================

init([Type]) ->
    Self = self(),
    EventFilter =
        fun (?CHRONICLE_SECRETS_KEY = K) -> {true, {config_change, K}};
            (Key) ->
                case Type == ?NODE_PROC andalso
                     cb_deks:dek_chronicle_keys_filter(Key) of
                    false -> false;
                    List -> {true, {dek_settings_updated, List}}
                end
        end,
    chronicle_compat_events:subscribe(
      fun (Key) ->
          case EventFilter(Key) of
              false -> ok;
              {true, M} -> Self ! M
          end
      end),
    Jobs = case Type of
               ?MASTER_PROC ->
                   [maybe_reencrypt_secrets,
                    maybe_reset_deks_counters];
               ?NODE_PROC ->
                    lists:flatmap(fun (K) ->
                                      [{maybe_update_deks, K},
                                       {garbage_collect_deks, K}]
                                  end, cb_deks:dek_kinds_list()) ++
                   [garbage_collect_keks,
                    ensure_all_keks_on_disk,
                    maybe_reencrypt_deks]
           end,
    {ok, functools:chain(#state{proc_type = Type, jobs = Jobs},
                         [run_jobs(_),
                          restart_dek_cleanup_timer(_),
                          restart_rotation_timer(_)])}.

handle_call({call, {M, F, A} = MFA}, _From,
            #state{proc_type = ?MASTER_PROC} = State) ->
    try
        ?log_debug("Calling ~p", [MFA]),
        {reply, {succ, erlang:apply(M, F, A)}, restart_rotation_timer(State)}
    catch
        C:E:ST ->
            ?log_warning("Call ~p failed: ~p:~p~n~p", [MFA, C, E, ST]),
            {reply, {exception, {C, E, ST}}, restart_rotation_timer(State)}
    end;

handle_call(sync, _From, #state{proc_type = ?NODE_PROC} = State) ->
    {reply, ok, State};

handle_call(get_node_deks_info, _From,
            #state{proc_type = ?NODE_PROC} = State) ->
    NewState = run_jobs(State), %% Run jobs to make sure all deks are up to date
    maybe
        [] ?= NewState#state.jobs,
        StripKeyMaterial =
            fun (Keys) ->
                lists:map(fun (#{type := 'raw-aes-gcm', info := Info} = K) ->
                              K#{info => maps:remove(key, Info)}
                          end, Keys)
            end,
        #state{deks = Deks} = NewState,
        Res = maps:map(fun (_K, #{deks := Keys}) -> StripKeyMaterial(Keys) end,
                       Deks),
        {reply, Res, NewState}
    else
        [_ | _] ->
            %% There are still unfinished jobs. That means deks in our state
            %% can be not up to date (dek might exist on disk, but this
            %% process hasn't read it yet). Since this function is used
            %% in final checks before kek removal, it should not return
            %% {ok, _} reuslt in this case
            {reply, retry, NewState}
    end;

handle_call(Request, _From, State) ->
    ?log_warning("Unhandled call: ~p", [Request]),
    {noreply, State}.

handle_cast(Msg, State) ->
    ?log_warning("Unhandled cast: ~p", [Msg]),
    {noreply, State}.

handle_info({config_change, ?CHRONICLE_SECRETS_KEY} = Msg,
            #state{proc_type = ?NODE_PROC} = State) ->
    ?log_debug("Secrets in chronicle have changed..."),
    misc:flush(Msg),
    NewJobs = [garbage_collect_keks,     %% Removal of generated keks and AWS
               ensure_all_keks_on_disk,  %% Adding keks + AWS key change
               maybe_reencrypt_deks],    %% Keks rotation
    {noreply, add_and_run_jobs(NewJobs, State)};

handle_info({config_change, ?CHRONICLE_SECRETS_KEY} = Msg,
            #state{proc_type = ?MASTER_PROC} = State) ->
    ?log_debug("Secrets in chronicle have changed..."),
    misc:flush(Msg),
    NewJobs = [maybe_reencrypt_secrets], %% Modififcation of encryptBy or
                                         %% rotation of secret that encrypts
                                         %% other secrets
    {noreply, add_and_run_jobs(NewJobs, State)};

handle_info({config_change, _}, State) ->
    {noreply, State};

handle_info({dek_settings_updated, KindList},
            #state{proc_type = ?NODE_PROC} = State) ->
    ?log_debug("Dek settings updated for ~p", [KindList]),
    NewState = functools:chain(
                 State,
                 [add_and_run_jobs(
                    [{maybe_update_deks, Kind} || Kind <- KindList] ++
                    [{maybe_reencrypt_deks, Kind} || Kind <- KindList],
                    _),
                  %% We should restart these timers because rotation settings
                  %% can change
                  restart_dek_rotation_timer(_),
                  restart_dek_cleanup_timer(_)]),
    {noreply, NewState};

handle_info({timer, retry_jobs}, State) ->
    ?log_debug("Retrying jobs"),
    misc:flush({timer, retry_jobs}),
    {noreply, run_jobs(State)};

handle_info({timer, rotate_keks}, #state{proc_type = ?MASTER_PROC} = State) ->
    ?log_debug("Rotate keks timer"),
    misc:flush({timer, rotate_keks}),
    CurTime = calendar:universal_time(),
    %% Intentionally update next_rotation time first, and run rotations after.
    %% Reason: in case of a crash during rotation we don't want to retry.
    %% Rotation generates keys. If we get stuck in a loop, we can generate
    %% too many keys which can lead to unpredictable results.
    IdsToRotate = update_secrets(update_next_rotation_time(CurTime, _)),
    lists:foreach(
      fun (Id) ->
          try
              ok = rotate_internal(Id)
          catch
              C:E:ST ->
                  ?log_error("Secret #~p rotation crashed: ~p:~p~n~p",
                             [Id, C, E, ST])
          end
      end, IdsToRotate),
    {noreply, restart_rotation_timer(State)};

handle_info({timer, dek_cleanup} = Msg, #state{proc_type = ?NODE_PROC,
                                               deks = DeksInfo} = State) ->
    ?log_debug("DEK cleanup timer"),
    misc:flush(Msg),
    NewState =
        maps:fold(
          fun (Kind, KindDeks, StateAcc) ->
              case deks_to_drop(Kind, KindDeks) of
                  [] -> StateAcc;
                  ToDrop -> initiate_deks_drop(Kind, ToDrop, StateAcc)
              end
          end, State, DeksInfo),
    {noreply, restart_dek_cleanup_timer(NewState)};

handle_info({dek_drop_complete, Kind} = Msg,
            #state{proc_type = ?NODE_PROC} = State) ->
    ?log_debug("Dek drop complete: ~p", [Kind]),
    misc:flush(Msg),
    {noreply, add_and_run_jobs([{garbage_collect_deks, Kind}], State)};

handle_info({timer, rotate_deks} = Msg, #state{proc_type = ?NODE_PROC,
                                               deks = Deks} = State) ->
    ?log_debug("Rotate DEKs timer"),
    misc:flush(Msg),
    CurDT = calendar:universal_time(),
    NewJobs = maps:fold(fun (Kind, KindDeks, Acc) ->
                            Snapshot = deks_config_snapshot(Kind),
                            case dek_rotation_needed(Kind, KindDeks, CurDT,
                                                     Snapshot) of
                                true ->
                                    ?log_debug("Dek rotation needed for ~p",
                                               [Kind]),
                                    [{maybe_update_deks, Kind} | Acc];
                                false -> Acc
                            end
                        end, [], Deks),
    {noreply, restart_dek_rotation_timer(add_and_run_jobs(NewJobs, State))};

handle_info(Info, State) ->
    ?log_warning("Unhandled info: ~p", [Info]),
    {noreply, State}.

terminate(_Reason, _State) ->
    ok.

%%%===================================================================
%%% Internal functions
%%%===================================================================

-spec generate_key(Creation :: calendar:datetime(), secret_props()) ->
                                            {ok, kek_props()} |
                                            {error, bad_encrypt_id()}.
generate_key(CreationDateTime, #{data := SecretData}) ->
    maybe
        Key = generate_raw_key(?ENVELOP_CIPHER),
        {ok, EncryptedBy} ?=
            case SecretData of
                #{encrypt_by := nodeSecretManager} -> {ok, undefined};
                #{encrypt_by := clusterSecret,
                  encrypt_secret_id := EncSecretId} ->
                    case get_active_key_id(EncSecretId, direct) of
                        {ok, EncKekId} ->
                            {ok, {EncSecretId, EncKekId}};
                        {error, not_found} ->
                            {error, {encrypt_id, not_found}};
                        {error, not_supported} ->
                            {error, {encrypt_id, not_allowed}}
                    end
            end,
        KeyProps = #{id => new_key_id(),
                     creation_time => CreationDateTime,
                     key => {sensitive, Key},
                     encrypted_by => undefined},
        case maybe_reencrypt_kek(KeyProps, EncryptedBy) of
            no_change -> {ok, KeyProps};
            NewKeyProps -> {ok, NewKeyProps}
        end
    else
        {error, Reason} -> {error, Reason}
    end.

-spec set_active_key_in_props(secret_props(), key_id()) -> secret_props().
set_active_key_in_props(#{type := ?GENERATED_KEY_TYPE,
                          data := Data} = SecretProps,
                        KeyId) ->
    SecretProps#{data => Data#{active_key_id => KeyId}}.

-spec set_keys_in_props(secret_props(), [kek_props()]) -> secret_props().
set_keys_in_props(#{type := ?GENERATED_KEY_TYPE, data := Data} = SecretProps,
                  Keys) ->
    SecretProps#{data => Data#{keys => Keys}}.

-spec copy_static_props(secret_props(), secret_props()) -> secret_props().
%% Copies properties that secret can never change
copy_static_props(#{type := Type, id := Id,
                    creation_time := CreationDT} = OldSecretProps,
                  #{type := Type} = NewSecretProps) ->
    NewSecretProps2 = NewSecretProps#{id => Id, creation_time => CreationDT},
    case NewSecretProps2 of
        #{type := ?GENERATED_KEY_TYPE} ->
            #{data := #{active_key_id := OldActiveId, keys := Keys} = OldData} =
                OldSecretProps,
            LastRotationTime = maps:get(last_rotation_time, OldData, undefined),
            functools:chain(
              NewSecretProps2,
              [set_keys_in_props(_, Keys),
               set_active_key_in_props(_, OldActiveId),
               set_last_rotation_time_in_props(_, LastRotationTime)]);
        #{type := ?AWSKMS_KEY_TYPE} ->
            #{data := #{uuid := UUID}} = OldSecretProps,
            #{data := NewData} = NewSecretProps2,
            NewSecretProps2#{data => NewData#{uuid => UUID}};
        _ ->
            NewSecretProps2
    end.

-spec replace_secret_in_list(secret_props(), [secret_props()]) ->
                                                      [secret_props()] | false.
replace_secret_in_list(NewProps, List) ->
    Id = maps:get(id, NewProps),
    ReplaceFun = fun Replace([], _Acc) -> false;
                     Replace([Next | Rest], Acc) ->
                         case maps:get(id, Next) of
                             Id -> lists:reverse([NewProps | Acc], Rest);
                             _ -> Replace(Rest, [Next | Acc])
                         end
                 end,
    ReplaceFun(List, []).

-spec add_active_key(secret_id(), kek_props(), boolean()) ->
                        ok | {error, not_found | encrypt_secret_has_changed}.
add_active_key(Id, #{id := KekId, encrypted_by := EncryptedBy} = Kek,
               true = _UpdateRotationTime) ->
    %% Id of the secret that encrypted that new kek
    ESecretId = case EncryptedBy of
                    undefined -> undefined;
                    {S, _} -> S
                end,
    RV = chronicle_kv:transaction(
           kv, [?CHRONICLE_SECRETS_KEY],
           fun (Snapshot) ->
               maybe
                   {ok, #{type := ?GENERATED_KEY_TYPE,
                          data := SecretData} = SecretProps} ?=
                       get_secret(Id, Snapshot),
                   #{keys := CurKeks} = SecretData,
                   ExpectedESecretId =
                      case SecretData of
                          #{encrypt_by := clusterSecret,
                            encrypt_secret_id := SId} -> SId;
                          #{encrypt_by := nodeSecretManager} -> undefined
                      end,
                   %% Making sure that encryption secret id hasn't changed
                   %% since we encrypted new active kek.
                   %% It should not normally happen because modification of
                   %% secrets and rotations are supposed to run in the same
                   %% process.
                   {expected, ExpectedESecretId} ?= {expected, ESecretId},
                   Time = calendar:universal_time(),
                   Updated = functools:chain(
                               SecretProps,
                               [set_keys_in_props(_, [Kek | CurKeks]),
                                set_active_key_in_props(_, KekId),
                                set_last_rotation_time_in_props(_, Time)]),
                   NewList = replace_secret_in_list(Updated,
                                                    get_all(Snapshot)),
                   true = is_list(NewList),
                   {commit, [{set, ?CHRONICLE_SECRETS_KEY, NewList}]}
               else
                   {error, not_found} ->
                       {abort, {error, not_found}};
                   {expected, _} ->
                       {abort, {error, encrypt_secret_has_changed}}
               end
           end),

    case RV of
        {ok, _} -> ok;
        {error, Reason} -> {error, Reason}
    end.

-spec ensure_all_keks_on_disk() -> ok | {error, list()}.
ensure_all_keks_on_disk() ->
    RV = lists:map(fun (#{id := Id,
                          type := ?GENERATED_KEY_TYPE} = SecretProps)  ->
                           {Id, ensure_generated_keks_on_disk(SecretProps)};
                       (#{id := Id, type := ?AWSKMS_KEY_TYPE} = SecretProps) ->
                           {Id, ensure_aws_kek_on_disk(SecretProps)};
                       (#{id := Id}) ->
                           {Id, ok}
                   end, get_all()),
    misc:many_to_one_result(RV).

-spec ensure_generated_keks_on_disk(secret_props()) -> ok | {error, list()}.
ensure_generated_keks_on_disk(#{type := ?GENERATED_KEY_TYPE, id := SecretId,
                                data := #{keys := Keys}}) ->
    ?log_debug("Ensure all keys are on disk for secret ~p "
               "(number of keys to check: ~b)", [SecretId, length(Keys)]),
    Res = lists:map(fun (#{id := Id} = K) ->
                        {Id, ensure_kek_on_disk(K)}
                    end, Keys),
    misc:many_to_one_result(Res).

-spec ensure_kek_on_disk(kek_props()) -> ok | {error, _}.
ensure_kek_on_disk(#{id := Id, key := {sensitive, Key},
                     encrypted_by := undefined,
                     creation_time := CreationTime}) ->
    encryption_service:store_kek(Id, Key, _IsEncrypted = false, undefined,
                                 CreationTime);
ensure_kek_on_disk(#{id := Id, key := {encrypted_binary, Key},
                     encrypted_by := {_ESecretId, EKekId},
                     creation_time := CreationTime}) ->
    encryption_service:store_kek(Id, Key, _IsEncrypted = true, EKekId,
                                 CreationTime).

-spec ensure_aws_kek_on_disk(secret_props()) -> ok | {error, _}.
ensure_aws_kek_on_disk(#{creation_time := CreationTime, data := Data}) ->
    #{uuid := UUID, key_arn := KeyArn, region := Region, profile := Profile,
      config_file := ConfigFile, credentials_file := CredsFile,
      use_imds := UseIMDS} = Data,
    encryption_service:store_awskey(UUID, KeyArn, Region, Profile,
                                    CredsFile, ConfigFile, UseIMDS,
                                    CreationTime).

-spec garbage_collect_keks() -> ok.
garbage_collect_keks() ->
    AllKekIds = all_kek_ids(),
    ?log_debug("keks gc: All existing keks: ~p", [AllKekIds]),
    case encryption_service:garbage_collect_keks(AllKekIds) of
        {ok, _} -> ok;
        {error, _} = Error -> Error
    end.

-spec all_kek_ids() -> [key_id()].
all_kek_ids() ->
    lists:flatmap(fun (#{type := ?AWSKMS_KEY_TYPE, data := #{uuid := UUID}}) ->
                          [UUID];
                      (#{type := ?GENERATED_KEY_TYPE,
                         data := #{keys := Keys}}) ->
                          [Id || #{id := Id} <- Keys];
                      (#{}) ->
                          []
                  end, get_all()).

-spec prepare_new_secret(secret_props()) ->
            {ok, secret_props()} | {error, not_supported | bad_encrypt_id()}.
prepare_new_secret(#{type := ?GENERATED_KEY_TYPE,
                     creation_time := CurrentTime} = Props) ->
    maybe
        %% Creating new auto-generated key
        {ok, #{id := KekId} = KeyProps} ?= generate_key(CurrentTime, Props),
        {ok, functools:chain(Props, [set_keys_in_props(_, [KeyProps]),
                                     set_active_key_in_props(_, KekId)])}
    else
        {error, _} = Error -> Error
    end;
prepare_new_secret(#{type := ?AWSKMS_KEY_TYPE, data := Data} = Props) ->
    {ok, Props#{data => Data#{uuid => new_key_id()}}};
prepare_new_secret(#{type := _Type}) ->
    {error, not_supported}.

-spec maybe_update_deks(cb_deks:dek_kind(), #state{}) ->
          {ok, #state{}} | {error, #state{}, term()}.
maybe_update_deks(Kind, #state{deks = CurDeks} = OldState) ->
    Snapshot = deks_config_snapshot(Kind),
    case call_dek_callback(encryption_method_callback, Kind, [Snapshot]) of
        {succ, {ok, EncrMethod}} ->
            %% Read DEKs if we don't have them yet
            State = #state{deks = AllDeks} =
                case maps:find(Kind, CurDeks) of
                    {ok, _} -> OldState;
                    error -> read_deks(Kind, OldState)
                end,

            #{Kind := #{active_id := ActiveId,
                        is_enabled := WasEnabled} = KindDeks} = AllDeks,

            CurDT = calendar:universal_time(),
            ShouldRotate = dek_rotation_needed(Kind, KindDeks, CurDT, Snapshot),

            %% Check current encryption settings and push actual active key to
            %% dek users
            case WasEnabled of

                %% On disk it is enabled but in config it is disabled:
                true when EncrMethod == disabled ->
                    ok = cb_deks:set_active(Kind, ActiveId, false),
                    NewState = add_jobs([{garbage_collect_deks, Kind}],
                                        read_deks(Kind, State)),
                    call_set_active_cb(Kind, NewState);

                %% It is enabled on disk and in config:
                true when not ShouldRotate ->
                    %% We should push it even when nothing changes in order to
                    %% handle the scenario when we crash between
                    %% cb_deks:set_active and SetActiveCB
                    call_set_active_cb(Kind, State);

                %% It is disabled on disk and in config:
                false when EncrMethod == disabled ->
                    %% We should push it even when nothing changes in order to
                    %% handle the scenario when we crash between
                    %% cb_deks:set_active and SetActiveCB
                    call_set_active_cb(Kind, State);

                %% On disk it is disabled but in config it is enabled
                %% and we already have a dek
                false when is_binary(ActiveId) and not ShouldRotate ->
                    ok = cb_deks:set_active(Kind, ActiveId, true),
                    NewState = read_deks(Kind, State),
                    call_set_active_cb(Kind, NewState);

                %% On disk it is disabled but in config it is enabled
                %% or rotation is needed
                V when (V == false) orelse ShouldRotate ->
                    %% There is no active dek currently, but encryption is on,
                    %% we should generate a new dek
                    case generate_new_dek(Kind, EncrMethod, Snapshot) of
                        ok ->
                            %% adding jobs inside a job, so there is no need to
                            %% call add_and_run_jobs
                            NewState = add_jobs([{garbage_collect_deks, Kind}],
                                                read_deks(Kind, State)),
                            call_set_active_cb(Kind, NewState);
                        {error, Reason} ->
                            {error, State, Reason}
                    end
            end;
        {succ, {error, not_found}} ->
            %% This entity doesn't exist anymore, nothing to do here
            %% We assume that DEKs are removed before that (for example, for
            %% buckets they are removed when the bucket dir is removed)
            %% Just make sure we don't monitor those DEKs anymore.
            %% Note that bucket can exist globally, but can be missing at this
            %% specific node.
            {ok, OldState#state{deks = maps:remove(Kind, CurDeks)}}
    end.

%% Remove DEKs that are not being used anymore
-spec garbage_collect_deks(cb_deks:dek_kind(), #state{}) ->
          {ok, #state{}} | {error, #state{}, term()}.
garbage_collect_deks(Kind, #state{deks = DeksInfo} = State) ->
    case maps:find(Kind, DeksInfo) of
        {ok, #{active_id := _ActiveId,
               deks := []}} ->
            %% There is no deks, nothing to remove
            {ok, State};
        {ok, #{is_enabled := true, deks := [_]}} ->
            %% If encryption is enabled, one dek is a minimum. Can't be removed.
            {ok, State};
        {ok, #{}} ->
            case call_dek_callback(get_ids_in_use_callback, Kind, []) of
                {succ, {ok, IdList}} ->
                    retire_unused_deks(Kind, IdList, State);
                {succ, {error, not_found}} ->
                    %% The entity that uses deks does not exist.
                    %% Ignoring it here because we assume that deks will
                    %% be removed by maybe_update_deks
                    {ok, State};
                {succ, {error, Reason}} ->
                    {error, State, Reason};
                {except, {_, E, _}} ->
                    {error, State, E}
            end;
        error ->
            {ok, State}
    end.

-spec retire_unused_deks(cb_deks:dek_kind(), [cb_deks:dek_id()], #state{}) ->
          {ok, #state{}} | {error, #state{}, term()}.
retire_unused_deks(Kind, DekIdsInUse0, State) ->
    case maybe_reset_active_file(Kind, DekIdsInUse0, State) of
        {ok, DekIdsInUse, NewState} ->
            case encryption_service:garbage_collect_keys(Kind, DekIdsInUse) of
                {ok, []} ->
                    {ok, NewState};
                {ok, _} ->
                    case cb_crypto:reset_dek_cache(Kind, cleanup) of
                        {ok, _} ->
                            {ok, read_deks(Kind, NewState)};
                        {error, Reason} ->
                            {error, NewState, Reason}
                    end;
                {error, Reason} ->
                    {error, NewState, Reason}
            end;
        {error, Reason} ->
            {error, State, Reason}
    end.

-spec maybe_reset_active_file(cb_deks:dek_kind(), [cb_deks:dek_id()],
                              #state{}) ->
          {ok, [cb_deks:dek_id()], #state{}} | {error, term()}.
%% Resets the active key file before active key removal
maybe_reset_active_file(Kind, DekIdsInUse, #state{deks = DeksInfo} = State) ->
    #{Kind := #{active_id := ActiveId, is_enabled := IsEnabled}} = DeksInfo,
    case lists:member(ActiveId, DekIdsInUse) of
        false when IsEnabled ->
            true = is_binary(ActiveId),
            ?log_error("Attempt to remove active dek ~p for ~p "
                       "while encryption is on", [ActiveId, Kind]),
            {ok, [ActiveId | DekIdsInUse], State};
        false when ActiveId == undefined ->
            {ok, DekIdsInUse, State};
        false ->
            %% This is ok to remove active dek because encryption is off
            %% and that key is not used anymore. We should remove it
            %% from "active" file though.
            maybe
                ok ?= cb_deks:set_active(Kind, undefined, false),
                {ok, _} ?= cb_crypto:reset_dek_cache(Kind, cleanup),
                {ok, DekIdsInUse, read_deks(Kind, State)}
            end;
        true ->
            {ok, DekIdsInUse, State}
    end.

-spec call_set_active_cb(cb_deks:dek_kind(), #state{}) ->
          {ok, #state{}} | {error, #state{}, term()}.
call_set_active_cb(Kind, #state{deks = AllDeks} = State) ->
    #{Kind := #{active_id := ActiveId,
                deks := Keys,
                is_enabled := IsEnabled}} = AllDeks,
    NewActiveKey =
        case IsEnabled of
            true ->
                {value, ActiveKey} = lists:search(fun (#{id := Id}) ->
                                                        Id == ActiveId
                                                  end, Keys),
                ActiveKey;
            false -> undefined
        end,
    case cb_crypto:reset_dek_cache(Kind, {new_active, NewActiveKey}) of
        {ok, _} ->
            case call_dek_callback(set_active_key_callback, Kind,
                                   [NewActiveKey]) of
                {succ, ok} ->
                    {ok, State};
                {succ, {ok, DekIdsInUse}} ->
                    retire_unused_deks(Kind, DekIdsInUse, State);
                {succ, {error, Reason}} ->
                    {error, State, Reason};
                {except, {_, E, _}} ->
                    {error, State, E}
            end;
        {error, Reason} ->
            {error, State, Reason}
    end.

call_dek_callback(CallbackName, Kind, Args) ->
    #{CallbackName := CB} = cb_deks:dek_config(Kind),
    try erlang:apply(CB, Args) of
        RV ->
            ?log_debug("~p for ~p returned: ~p", [CallbackName, Kind, RV]),
            {succ, RV}
    catch
        C:E:ST ->
            ?log_error("~p for ~p crash ~p:~p~n~p",
                       [CallbackName, Kind, C, E, ST]),
            {except, {C, E, ST}}
    end.

-spec read_deks(cb_deks:dek_kind(), #state{}) -> #state{}.
read_deks(Kind, #state{deks = AllDeks} = State) ->
    {ok, {ActiveDek, DekIds, Info}} = cb_deks:list(Kind),
    IsEnabled = case Info of
                    true -> true;
                    false -> false;
                    undefined -> false
                end,
    {ok, Deks} = cb_deks:read(Kind, DekIds),
    CurKindDeks = maps:get(Kind, AllDeks, #{}),
    CurDeksDropped = maps:get(deks_being_dropped, CurKindDeks, []),
    CurDeksDroppedCleaned = CurDeksDropped -- (CurDeksDropped -- DekIds),
    CurLastDropTS = maps:get(last_drop_timestamp, CurKindDeks, undefined),
    KindDeks = #{active_id => ActiveDek,
                 deks => Deks,
                 is_enabled => IsEnabled,
                 deks_being_dropped => CurDeksDroppedCleaned,
                 last_drop_timestamp => CurLastDropTS},
    functools:chain(State#state{deks = AllDeks#{Kind => KindDeks}},
                    [restart_dek_cleanup_timer(_),
                     restart_dek_rotation_timer(_)]).

-spec generate_new_dek(cb_deks:dek_kind(), cb_deks:encryption_method(),
                       chronicle_snapshot()) -> ok | {error, _}.
generate_new_dek(Kind, EncryptionMethod, Snapshot) ->
    maybe
        ?log_debug("Generating new ~p dek, encryption is ~p...",
                   [Kind, EncryptionMethod]),
        {ok, DekId} ?= cb_deks:generate_new(Kind, EncryptionMethod, Snapshot),
        ok ?= cb_deks:set_active(Kind, DekId, true),
        ok
    end.

-spec maybe_reencrypt_deks(#state{}) ->
          {ok, #state{}} | {error, list()}.
maybe_reencrypt_deks(#state{deks = Deks} = State) ->
    {AllErrors, NewState} =
        lists:foldl(
          fun (Kind, {ErrorsAcc, StateAcc}) ->
              case maybe_reencrypt_deks(Kind, StateAcc) of
                  {ok, NewStateAcc} -> {ErrorsAcc, NewStateAcc};
                  {error, NewStateAcc, Error} ->
                      NewErrorsAcc = [{Kind, Error} | ErrorsAcc],
                      {NewErrorsAcc, NewStateAcc}
              end
          end, {[], State}, maps:keys(Deks)),
    case AllErrors of
        [] -> {ok, NewState};
        _ -> {error, NewState, AllErrors}
    end.

-spec maybe_reencrypt_deks(cb_deks:dek_kind(), #state{}) ->
          {ok, #state{}} | {error, #state{}, term()}.
maybe_reencrypt_deks(Kind, #state{deks = Deks} = State) ->
    maybe
        {ok, #{deks := Keys}} ?= maps:find(Kind, Deks),
        Snapshot = deks_config_snapshot(Kind),
        {succ, {ok, EncrMethod}} ?= call_dek_callback(
                                      encryption_method_callback,
                                      Kind,
                                      [Snapshot]),
        RV = cb_deks:maybe_reencrypt_deks(Kind, Keys, EncrMethod, Snapshot),
        ?log_debug("Maybe reencrypt dek for ~p ~p ~p. Result: ~p",
                   [Kind, Keys, EncrMethod, RV]),
        case RV of
            no_change ->
                {ok, State};
            {changed, Errors} ->
                NewState = read_deks(Kind, State),
                case Errors of
                    [] -> {ok, NewState};
                    _ -> {error, NewState, Errors}
                end;
            {error, Error} ->
                {error, State, Error}
        end
    else
        error ->
            {ok, State};
        {succ, {error, not_found}} ->
            {ok, State}
    end.

-spec deks_config_snapshot(cb_deks:dek_kind()) -> chronicle_snapshot().
deks_config_snapshot(Kind) ->
    DekKeys = maps:get(chronicle_txn_keys, cb_deks:dek_config(Kind)),
    {ok, {Snapshot, _}} = chronicle_kv:get_snapshot(kv,
                                                    [?CHRONICLE_SECRETS_KEY |
                                                     DekKeys]),
    Snapshot.

-spec get_all_keys_from_props(secret_props()) -> [key_id()].
get_all_keys_from_props(#{type := ?GENERATED_KEY_TYPE,
                          data := #{keys := Keys}}) ->
    lists:map(fun (#{id := Id}) -> Id end, Keys);
get_all_keys_from_props(#{type := ?AWSKMS_KEY_TYPE,
                          data := #{uuid := Id}}) ->
    [Id].

-spec validate_secret_in_txn(secret_props(), #{} | secret_props(),
                             chronicle_snapshot()) ->
                                            ok | {error, bad_encrypt_id() |
                                                         bad_usage_change()}.
validate_secret_in_txn(NewProps, PrevProps, Snapshot) ->
    maybe
        ok ?= validate_secrets_encryption_usage_change(NewProps, PrevProps,
                                                       Snapshot),
        ok ?= validate_dek_related_usage_change(NewProps, PrevProps, Snapshot),
        ok ?= validate_encryption_secret_id(NewProps, Snapshot),
        ok ?= validate_name_uniqueness(NewProps, Snapshot)
    end.

-spec execute_on_master({module(), atom(), [term()]}) -> term().
execute_on_master({_, _, _} = MFA) ->
    misc:wait_for_global_name(cb_cluster_secrets_master),
    case gen_server:call(?MASTER_MONITOR_NAME, {call, MFA}, 60000) of
        {succ, Res} -> Res;
        {exception, {C, E, ST}} -> erlang:raise(C, E, ST)
    end.

-spec can_delete_secret(secret_props(), chronicle_snapshot()) ->
                                            ok | {error, secret_in_use()}.
can_delete_secret(#{id := Id}, Snapshot) ->
    %% Places where this secret is used directly in encryption configuration
    EncryptionConfigUsages =
        lists:filtermap(
          fun (Kind) ->
               case call_dek_callback(encryption_method_callback, Kind,
                                      [Snapshot]) of
                  {succ, {ok, {secret, Id}}} ->
                      {true, Kind};
                  {succ, {ok, _}} ->
                      false;
                  {succ, {error, not_found}} ->
                      false
              end
          end, cb_deks:dek_kinds_list(Snapshot)),
    %% Places where this secret is used for encryption of another secrets
    Secrets = get_secrets_used_by_secret_id(Id, Snapshot),
    %% Places where this secret is used to encrypt deks (such deks can exist
    %% even if encryption is disabled for this entity)
    Deks = get_dek_kinds_used_by_secret_id(Id, Snapshot),
    SecretNames =
        lists:map(fun (SId) ->
                      {ok, #{name := SName}} = get_secret(SId, Snapshot),
                      SName
                  end, Secrets),

    case length(EncryptionConfigUsages) + length(SecretNames) + length(Deks) of
        0 -> ok;
        _ ->
            M = #{by_config => EncryptionConfigUsages,
                  by_secrets => SecretNames,
                  by_deks => Deks},
            {error, {used_by, M}}
    end.

-spec get_secrets_used_by_secret_id(secret_id(), chronicle_snapshot()) ->
                                                                [secret_id()].
get_secrets_used_by_secret_id(Id, Snapshot) ->
    lists:filtermap(
      fun (#{type := ?GENERATED_KEY_TYPE,
             id := SecretId,
             data := #{encrypt_by := clusterSecret,
                       encrypt_secret_id := Id2}}) when Id2 == Id ->
                {true, SecretId};
           (#{}) ->
                false
      end, get_all(Snapshot)).

-spec get_dek_kinds_used_by_secret_id(secret_id(), chronicle_snapshot()) ->
                                                        [cb_deks:dek_kind()].
get_dek_kinds_used_by_secret_id(Id, Snapshot) ->
    Map = chronicle_compat:get(Snapshot,
                               ?CHRONICLE_DEK_COUNTERS_KEY,
                               #{default => #{}}),
    maps:keys(maps:get({secret, Id}, Map, #{})).

-spec get_active_key_id_from_secret(secret_props()) -> {ok, key_id()} |
                                                       {error, not_supported}.
get_active_key_id_from_secret(#{type := ?GENERATED_KEY_TYPE,
                                data := #{active_key_id := Id}}) ->
    {ok, Id};
get_active_key_id_from_secret(#{type := ?AWSKMS_KEY_TYPE,
                                data := #{uuid := UUID}}) ->
    {ok, UUID};
get_active_key_id_from_secret(#{}) ->
    {error, not_supported}.

-spec maybe_reencrypt_secrets() -> ok.
maybe_reencrypt_secrets() ->
    RV = chronicle_kv:transaction(
           kv, [?CHRONICLE_SECRETS_KEY],
           fun (Snapshot) ->
               All = get_all(Snapshot),
               KeksMap =
                   maps:from_list(
                     lists:filtermap(
                       fun (#{id := Id} = P) ->
                           maybe
                               {ok, KekId} ?= get_active_key_id_from_secret(P),
                               {true, {Id, KekId}}
                           else
                               {error, not_supported} ->
                                   false
                           end
                       end, All)),
               {Changed, Unchanged} =
                   misc:partitionmap(
                     fun (Secret) ->
                         case maybe_reencrypt_secret_txn(Secret, KeksMap) of
                             {true, NewSecret} -> {left, NewSecret};
                             false -> {right, Secret}
                         end
                     end, All),
               case Changed of
                   [] -> {abort, no_change};
                   [_ | _] ->
                       NewSecretsList = Changed ++ Unchanged,
                       {commit, [{set, ?CHRONICLE_SECRETS_KEY, NewSecretsList}]}
               end
           end),
    case RV of
        {ok, _} ->
            sync_with_node_monitor(),
            ok;
        no_change -> ok
    end.

-spec maybe_reencrypt_secret_txn(secret_props(), #{secret_id() := key_id()}) ->
                                                false | {true, secret_props()}.
maybe_reencrypt_secret_txn(#{type := ?GENERATED_KEY_TYPE} = Secret, KeksMap) ->
    #{data := #{keys := Keys} = Data} = Secret,
    case maybe_reencrypt_keks(Keys, Secret, KeksMap) of
        {ok, NewKeks} -> {true, Secret#{data => Data#{keys => NewKeks}}};
        no_change -> false
    end;
maybe_reencrypt_secret_txn(#{}, _) ->
    false.

-spec maybe_reencrypt_keks([kek_props()], secret_props(),
                           #{secret_id() := key_id()}) ->
                                                {ok, [kek_props()]} | no_change.
maybe_reencrypt_keks(Keys, #{data := SecretData}, KeksMap) ->
    NewEncryptedBy =
        case SecretData of
            #{encrypt_by := nodeSecretManager} -> undefined;
            #{encrypt_by := clusterSecret,
              encrypt_secret_id := TargetSecretId} ->
                TargetKekId = maps:get(TargetSecretId, KeksMap),
                {TargetSecretId, TargetKekId}
        end,
    RV = lists:mapfoldl(
           fun (Key, Acc) ->
               case maybe_reencrypt_kek(Key, NewEncryptedBy) of
                   no_change -> {Key, Acc};
                   NewKey -> {NewKey, changed}
               end
           end, no_change, Keys),
    case RV of
        {NewKeyList, changed} -> {ok, NewKeyList};
        {_, no_change} -> no_change
    end.

-spec maybe_reencrypt_kek(kek_props(), undefined | {secret_id(), key_id()}) ->
                                                        no_change | kek_props().
%% Already encrypted with correct key
maybe_reencrypt_kek(#{key := {encrypted_binary, _},
                      encrypted_by := {SecretId, KekId}},
                    {SecretId, KekId}) ->
    no_change;
%% Encrypted with wrong key, should reencrypt
maybe_reencrypt_kek(#{key := {encrypted_binary, Bin},
                      encrypted_by := {_SecretId, KekId}} = Key,
                    {NewSecretId, NewKekId}) ->
    {ok, RawKey} = encryption_service:decrypt_key(Bin, KekId),
    {ok, EncryptedKey} = encryption_service:encrypt_key(RawKey, NewKekId),
    Key#{key => {encrypted_binary, EncryptedKey},
         encrypted_by => {NewSecretId, NewKekId}};
%% Encrypted, but we want it to be unencrypted (encrypted by node SM actually)
maybe_reencrypt_kek(#{key := {encrypted_binary, Bin},
                      encrypted_by := {_SecretId, KekId}} = Key,
                    undefined) ->
    {ok, RawKey} = encryption_service:decrypt_key(Bin, KekId),
    Key#{key => {sensitive, RawKey}, encrypted_by => undefined};
%% Not encrypted but should be
maybe_reencrypt_kek(#{key := {sensitive, Bin},
                      encrypted_by := undefined} = Key,
                    {NewSecretId, NewKekId}) ->
    {ok, EncryptedKey} = encryption_service:encrypt_key(Bin, NewKekId),
    Key#{key => {encrypted_binary, EncryptedKey},
         encrypted_by => {NewSecretId, NewKekId}};
%% Not encrypted, and that's right
maybe_reencrypt_kek(#{key := {sensitive, _Bin},
                      encrypted_by := undefined},
                    undefined) ->
    no_change.

-spec add_jobs([node_job()] | [master_job()], #state{}) -> #state{}.
add_jobs(NewJobs, #state{jobs = Jobs} = State) ->
    State#state{jobs = NewJobs ++ (Jobs -- NewJobs)}.

-spec add_and_run_jobs([node_job()] | [master_job()], #state{}) -> #state{}.
add_and_run_jobs(NewJobs, State) ->
    run_jobs(add_jobs(NewJobs, State)).

-spec run_jobs(#state{}) -> #state{}.
run_jobs(#state{jobs = Jobs} = State) ->
    {NewJobsReversed, NewState} =
        lists:foldl(
          fun (J, {JobsAcc, StateAcc}) ->
              ?log_debug("Starting job: ~p", [J]),
              try do(J, StateAcc) of
                  {ok, NewStateAcc} ->
                      ?log_debug("Job complete: ~p", [J]),
                      {JobsAcc, NewStateAcc};
                  ok ->
                      ?log_debug("Job complete: ~p", [J]),
                      {JobsAcc, StateAcc};
                  {error, retry} ->
                      ?log_debug("Job ~p returned 'retry'", [J]),
                      {[J | JobsAcc], StateAcc};
                  {error, NewStateAcc, retry} ->
                      ?log_debug("Job ~p returned 'retry'", [J]),
                      {[J | JobsAcc], NewStateAcc};
                  {error, NewStateAcc, Error} ->
                      ?log_error("Job ~p returned error: ~p", [J, Error]),
                      {[J | JobsAcc], NewStateAcc};
                  BadRes ->
                      ?log_error("Job ~p returned: ~p", [J, BadRes]),
                      {[J | JobsAcc], StateAcc}
              catch
                  C:E:ST ->
                      ?log_error("Job ~p failed: ~p:~p~nStacktrace:~p~n"
                                 "State: ~p", [J, C, E, ST, State]),
                      {[J | JobsAcc], StateAcc}
              end
          end, {[], State#state{jobs = []}}, Jobs),

    UpdatedState = add_jobs(lists:reverse(NewJobsReversed), NewState),
    case UpdatedState#state.jobs of
        [] -> stop_timer(retry_jobs, UpdatedState);
        [_ | _] -> restart_timer(retry_jobs, ?RETRY_TIME, UpdatedState)
    end.

-spec do(node_job() | master_job(), #state{}) ->
          ok | {ok, #state{}} | retry | {error, _} | {error, #state{}, _}.
do(garbage_collect_keks, _) ->
    garbage_collect_keks();
do(ensure_all_keks_on_disk, _) ->
    ensure_all_keks_on_disk();
do(maybe_reencrypt_secrets, _) ->
    maybe_reencrypt_secrets();
do(maybe_reset_deks_counters, _) ->
    maybe_reset_deks_counters();
do({maybe_update_deks, Kind}, State) ->
    maybe_update_deks(Kind, State);
do({garbage_collect_deks, Kind}, State) ->
    garbage_collect_deks(Kind, State);
do({maybe_reencrypt_deks, K}, State) ->
    maybe_reencrypt_deks(K, State);
do(maybe_reencrypt_deks, State) ->
    maybe_reencrypt_deks(State).

-spec stop_timer(Name :: atom(), #state{}) -> #state{}.
stop_timer(Name, #state{timers = Timers} = State) ->
    case maps:get(Name, Timers) of
        undefined -> State;
        Ref ->
            erlang:cancel_timer(Ref),
            State#state{timers = Timers#{Name => undefined}}
    end.

-spec restart_timer(Name :: atom(), Time :: non_neg_integer(), #state{}) ->
          #state{}.
restart_timer(Name, Time, #state{timers = Timers} = State) ->
    NewState = stop_timer(Name, State),
    ?log_debug("Starting ~p timer for ~b...", [Name, Time]),
    Ref = erlang:send_after(Time, self(), {timer, Name}),
    NewState#state{timers = Timers#{Name => Ref}}.

-spec restart_rotation_timer(#state{}) -> #state{}.
restart_rotation_timer(#state{proc_type = ?NODE_PROC} = State) ->
    State;
restart_rotation_timer(#state{proc_type = ?MASTER_PROC} = State) ->
    CurDateTime = calendar:universal_time(),
    Time = calculate_next_rotation_time(CurDateTime, get_all()),
    ?log_debug("Starting rotation timer for ~b...", [Time]),
    restart_timer(rotate_keks, Time, State).

-spec calculate_next_rotation_time(calendar:datetime(), [secret_props()]) ->
                                            TimeInMs :: non_neg_integer().
calculate_next_rotation_time(CurDateTime, Secrets) ->
    Times = [T || S <- Secrets, T <- [get_rotation_time(S)], T =/= undefined],
    time_to_first_event(CurDateTime, Times).

-spec get_rotation_time(secret_props()) -> calendar:datetime() | undefined.
get_rotation_time(#{type := ?GENERATED_KEY_TYPE,
                    data := #{auto_rotation := true,
                              next_rotation_time := Next}}) ->
    Next;
get_rotation_time(#{}) ->
    undefined.

-spec time_to_first_event(calendar:datetime(), [calendar:datetime()]) ->
          non_neg_integer().
time_to_first_event(_CurDateTime, []) -> ?MAX_RECHECK_ROTATION_INTERVAL;
time_to_first_event(CurDateTime, EventTimes) ->
    MinDateTime = lists:min(EventTimes),
    CurSec = calendar:datetime_to_gregorian_seconds(CurDateTime),
    MinSec = calendar:datetime_to_gregorian_seconds(MinDateTime),
    TimeRemains = max(?MIN_RECHECK_ROTATION_INTERVAL, (MinSec - CurSec) * 1000),
    min(?MAX_RECHECK_ROTATION_INTERVAL, TimeRemains).

-spec restart_dek_cleanup_timer(#state{}) -> #state{}.
restart_dek_cleanup_timer(#state{proc_type = ?MASTER_PROC} = State) ->
    State;
restart_dek_cleanup_timer(#state{proc_type = ?NODE_PROC,
                                 deks = DeksInfo} = State) ->
    CurDateTime = calendar:universal_time(),
    Time = calculate_next_dek_cleanup(CurDateTime, DeksInfo),
    restart_timer(dek_cleanup, Time, State).

-spec calculate_next_dek_cleanup(calendar:datetime(), #{}) ->
          TimeInMs :: non_neg_integer().
calculate_next_dek_cleanup(CurDateTime, DeksInfo) ->
    Times =
        maps:fold(
          fun (Kind, KindDeks, Acc) ->
              Snapshot = deks_config_snapshot(Kind),
              case call_dek_callback(lifetime_callback, Kind, [Snapshot]) of
                  {succ, {ok, undefined}} ->
                      Acc;
                  {succ, {ok, LifeTimeInSec}} ->
                      ExpirationTimes = dek_expiration_times(LifeTimeInSec,
                                                             KindDeks),
                      [DT || {DT, _} <- ExpirationTimes] ++ Acc;
                  {succ, {error, not_found}} ->
                      %% Assume there is not such entity anymore, we just
                      %% haven't removed deks yet, ignoring them
                      Acc;
                  {except, _} ->
                      [misc:datetime_add(CurDateTime,
                                         ?DEK_TIMER_RETRY_TIME_S) | Acc]
              end
          end, [], DeksInfo),
    time_to_first_event(CurDateTime, Times).

-spec get_expired_deks(cb_deks:dek_kind(), deks_info()) ->
          [cb_deks:dek_id()].
get_expired_deks(Kind, DeksInfo) ->
    Snapshot = deks_config_snapshot(Kind),
    case call_dek_callback(lifetime_callback, Kind, [Snapshot]) of
        {succ, {ok, undefined}} ->
            [];
        {succ, {ok, LifeTimeInSec}} ->
            DekExpirationTimes = dek_expiration_times(LifeTimeInSec, DeksInfo),
            CurDateTime = calendar:universal_time(),
            lists:filtermap(fun ({ExpirationTime, Id}) ->
                             case CurDateTime >= ExpirationTime of
                                 true -> {true, Id};
                                 false -> false
                             end
                         end, DekExpirationTimes);
        {succ, {error, not_found}} ->
            [];
        {except, _} ->
            []
    end.

-spec dek_expiration_times(non_neg_integer(), deks_info()) ->
          [{calendar:datetime(), cb_deks:dek_id()}].
dek_expiration_times(LifetimeInSec, #{deks := Deks}) ->
    CreationTimes = lists:map(
                      fun (#{type := 'raw-aes-gcm',
                             id := Id,
                             info := #{creation_time := Time}}) ->
                          {Time, Id}
                      end, Deks),
    [{misc:datetime_add(DT, LifetimeInSec), Id} || {DT, Id} <- CreationTimes].

-spec restart_dek_rotation_timer(#state{}) -> #state{}.
restart_dek_rotation_timer(#state{proc_type = ?MASTER_PROC} = State) ->
    State;
restart_dek_rotation_timer(#state{proc_type = ?NODE_PROC,
                                  deks = Deks} = State) ->
    CurDT = calendar:universal_time(),
    Times =
        maps:fold(fun (Kind, KindDeks, Acc) ->
                      Snapshot = deks_config_snapshot(Kind),
                      case dek_rotation_time(Kind, KindDeks, Snapshot) of
                          {value, ExpDT} -> [ExpDT | Acc];
                          false -> Acc;
                          {error, _} ->
                              [misc:datetime_add(CurDT,
                                                 ?DEK_TIMER_RETRY_TIME_S) | Acc]
                      end
                  end, [], Deks),
    TimerTime = time_to_first_event(CurDT, Times),
    restart_timer(rotate_deks, TimerTime, State).

-spec dek_rotation_needed(cb_deks:dek_kind(), deks_info(), calendar:datetime(),
                          chronicle_snapshot()) -> boolean().
dek_rotation_needed(Kind, KindDeks, CurDT, Snapshot) ->
    case dek_rotation_time(Kind, KindDeks, Snapshot) of
        {value, ExpDT} -> ExpDT =< CurDT;
        false -> false;
        {error, _} -> false
    end.

-spec dek_rotation_time(cb_deks:dek_kind(), deks_info(),
                        chronicle_snapshot()) ->
          {value, calendar:datetime()} | false | {error, _}.
dek_rotation_time(_Kind, #{is_enabled := false}, _Snapshot) ->
    false;
dek_rotation_time(Kind, #{is_enabled := true, active_id := ActiveId,
                          deks := Keys}, Snapshot) ->
    {value, #{type := 'raw-aes-gcm',
              info := #{creation_time := CDT}}} =
        lists:search(fun (#{id := Id}) -> Id == ActiveId end, Keys),
    case call_dek_callback(rotation_int_callback, Kind, [Snapshot]) of
        {succ, {ok, undefined}} ->
            false;
        {succ, {ok, ExpirationInSec}} ->
            {value, misc:datetime_add(CDT, ExpirationInSec)};
        {succ, {error, not_found}} ->
            false;
        {succ, {error, R}} ->
            ?log_error("Failed to calculate next rotation time for dek ~p: ~p",
                       [Kind, R]),
            {error, R};
        {except, {_, E, _}} ->
            ?log_error("Failed to calculate next rotation time for dek ~p: ~p",
                       [Kind, E]),
            {error, E}
    end.

-spec validate_encryption_secret_id(secret_props(), chronicle_snapshot()) ->
                    ok | {error, bad_encrypt_id()}.
validate_encryption_secret_id(#{type := ?GENERATED_KEY_TYPE,
                                data := #{encrypt_by := clusterSecret,
                                          encrypt_secret_id := Id}},
                              Snapshot) ->
    case secret_can_encrypt_secrets(Id, Snapshot) of
        ok -> ok;
        {error, not_found} -> {error, {encrypt_id, not_found}};
        {error, not_allowed} -> {error, {encrypt_id, not_allowed}}
    end;
validate_encryption_secret_id(#{}, _Snapshot) ->
    ok.

-spec secret_can_encrypt_secrets(secret_id(), chronicle_snapshot()) ->
                                        ok | {error, not_found | not_allowed}.
secret_can_encrypt_secrets(SecretId, Snapshot) ->
    case get_secret(SecretId, Snapshot) of
        {ok, #{usage := Usage}} ->
            case lists:member(secrets_encryption, Usage) of
                true -> ok;
                false -> {error, not_allowed}
            end;
        {error, not_found} -> {error, not_found}
    end.

-spec validate_secrets_encryption_usage_change(secret_props(),
                                               #{} | secret_props(),
                                               chronicle_snapshot()) ->
                                            ok | {error, bad_usage_change()}.
validate_secrets_encryption_usage_change(NewProps, PrevProps, Snapshot) ->
    validate_if_usage_removed(
      secrets_encryption, NewProps, PrevProps,
      fun (Id) ->
          case secret_encrypts_other_secrets(Id, Snapshot) of
              true -> {error, {usage, in_use}};
              false -> ok
          end
      end).

validate_dek_related_usage_change(_NewProps, PrevProps, _Snapshot)
                                                        when PrevProps == #{} ->
    ok;
validate_dek_related_usage_change(NewProps, PrevProps, Snapshot) ->
    %% Make sure that all dek users are still allowed to use this secret.
    %% For example, say this secret encrypts bucket "a" and
    %% OldProps contains {bucket_encryption, "a"} in the usage field.
    %% Then the following changes would be allowed:
    %%   1. [{bucket_encryption, "a"}] -> [{bucket_encryption, "*"}].
    %%   2. [{bucket_encryption, "a"}] -> [{bucket_encryption, "a"},
    %%                                     config_encryption].
    %% And the following changes would be disallowed:
    %%   1. [{bucket_encryption, "a"}] -> [{bucket_encryption, "b"}].
    %%   2. [{bucket_encryption, "a"}] -> [config_encryption].
    #{id := Id} = PrevProps,
    %% Check existing deks. If this secret still encrypts any deks, we should
    %% not allow corresponding usage removal
    KindsOfExistingDeks = get_dek_kinds_used_by_secret_id(Id, Snapshot),
    DekKindRequirements =
        fun (Kind) ->
            #{required_usage := Requirement} = cb_deks:dek_config(Kind),
            case lists:member(Kind, KindsOfExistingDeks) of
                true -> {true, Requirement};
                false ->
                    {succ, RV} = call_dek_callback(encryption_method_callback,
                                                   Kind,
                                                   [Snapshot]),
                    case {ok, {secret, Id}} == RV of
                        true -> {true, Requirement};
                        false -> false
                    end
            end
        end,
    InUseList = lists:filtermap(DekKindRequirements,
                                cb_deks:dek_kinds_list(Snapshot)),
    NewUsageList = maps:get(usage, NewProps, []),
    case is_allowed(InUseList, NewUsageList) of
        true -> ok;
        false -> {error, {usage, in_use}}
    end.

is_allowed(Requirements, ListOfAllowedUsages) ->
    lists:all(
      fun (Req) ->
          lists:any(
            fun (Usage) ->
                case Req of
                    Usage -> true;
                    {bucket_encryption, _} -> Usage == {bucket_encryption, "*"};
                    _ -> false
                end
            end,
            ListOfAllowedUsages)
      end, Requirements).

-spec validate_if_usage_removed(secret_usage(), secret_props(),
                                #{} | secret_props(),
                                fun((secret_id()) -> ok | {error, term()})) ->
                                            ok | {error, bad_usage_change()}.
validate_if_usage_removed(Usage, NewProps, PrevProps, Fun) ->
    PrevUsage = maps:get(usage, PrevProps, []),
    NewUsage = maps:get(usage, NewProps, []),
    case (not lists:member(Usage, NewUsage)) andalso
         (lists:member(Usage, PrevUsage)) of
        true ->
            #{id := PrevId} = PrevProps,
            Fun(PrevId);
        false ->
            ok
    end.

-spec secret_encrypts_other_secrets(secret_id(), chronicle_snapshot()) ->
                                                                    boolean().
secret_encrypts_other_secrets(Id, Snapshot) ->
    lists:any(fun (#{type := ?GENERATED_KEY_TYPE,
                     data := #{encrypt_by := clusterSecret,
                               encrypt_secret_id := EncId}}) ->
                      EncId == Id;
                  (#{}) ->
                      false
              end, get_all(Snapshot)).

-spec can_secret_props_encrypt_dek_kind(secret_props(), cb_deks:dek_kind()) ->
          boolean().
can_secret_props_encrypt_dek_kind(#{usage := UsageList}, DekKind) ->
    #{required_usage := Required} = cb_deks:dek_config(DekKind),
    is_allowed([Required], UsageList).

-spec update_secrets(
        fun((secret_props()) -> {value, secret_props()} | false)) ->
                                                    [UpdatedIds :: secret_id()].
update_secrets(Fun) ->
    RV = chronicle_kv:transaction(
           kv, [?CHRONICLE_SECRETS_KEY],
           fun (Snapshot) ->
               {NewList, ChangedIds} =
                   lists:mapfoldl(fun (#{id := Id} = S, Acc) ->
                                      case Fun(S) of
                                          {value, NewS} -> {NewS, [Id | Acc]};
                                          false -> {S, Acc}
                                      end
                                  end, [], get_all(Snapshot)),
               case ChangedIds of
                   [] -> {abort, no_change};
                   _ ->
                       {commit,
                        [{set, ?CHRONICLE_SECRETS_KEY, NewList}],
                        ChangedIds}
               end
           end),
    case RV of
        {ok, _, UpdatedIds} -> UpdatedIds;
        no_change -> []
    end.

-spec update_next_rotation_time(calendar:datetime(), secret_props()) ->
                                                {value, secret_props()} | false.
update_next_rotation_time(CurTime, #{type := ?GENERATED_KEY_TYPE,
                                     data := Data} = Secret) ->
    case Data of
        #{auto_rotation := true,
          next_rotation_time := NextTime,
          rotation_interval_in_days := IntervalInD}
                                                when CurTime >= NextTime ->
            NextTimeS = calendar:datetime_to_gregorian_seconds(NextTime),
            CurTimeS = calendar:datetime_to_gregorian_seconds(CurTime),
            IntervalS = IntervalInD * ?SECS_IN_DAY,
            %% How many intervals to skip
            %% This is needed for the case when the system was down for a long
            %% time, and it's been more than 1 rotation interval since last
            %% rotation. In other words, NewNextTime must be in future.
            N = (CurTimeS - NextTimeS) div IntervalS + 1,
            NewNextTimeS = NextTimeS + N * IntervalS,
            NewNextTime = calendar:gregorian_seconds_to_datetime(NewNextTimeS),
            NewData = Data#{next_rotation_time => NewNextTime},
            {value, Secret#{data => NewData}};
        #{} ->
            false
    end;
update_next_rotation_time(_CurTime, #{}) ->
    false.

-spec set_last_rotation_time_in_props(secret_props(),
                                      calendar:datetime() | undefined) ->
                                                            secret_props().
set_last_rotation_time_in_props(Secret, undefined) ->
    Secret;
set_last_rotation_time_in_props(#{type := ?GENERATED_KEY_TYPE,
                                  data := Data} = Secret, CurUTCTime) ->
    Secret#{data => Data#{last_rotation_time => CurUTCTime}}.

-spec sync_with_all_node_monitors() -> ok | {error, [atom()]}.
sync_with_all_node_monitors() ->
    Nodes = ns_node_disco:nodes_actual(),
    Res = erpc:multicall(Nodes, ?MODULE, sync_with_node_monitor, [],
                         ?SYNC_TIMEOUT),
    BadNodes = lists:filtermap(
                 fun ({_Node, {ok, _}}) ->
                         false;
                     ({Node, {Class, Exception}}) ->
                         ?log_error("Node ~p sync failed: ~p ~p",
                                    [Node, Class, Exception]),
                         {true, Node}
                 end, lists:zip(Nodes, Res)),
    case BadNodes of
        [] -> ok;
        _ ->
            ?log_error("Sync failed, bad nodes: ~p", [BadNodes]),
            {error, BadNodes}
    end.

%% Every time we start using a secret to encrypt a dek, we increment a counter
%% in chronicle. This is needed so we always have an understanding what secrets
%% are used for what (for example we need this information in order to be able
%% to remove KEKs safely).
%%
%% Current those counter look like the following:
%% #{ {secret, 23} => #{ chronicleDek => 14,
%%                       {bucketDek, "beer-sample"} => 2 },
%%    {secret, 26} => #{ {bucketDek, "travel-sample"} => 6 } }
%%
%% This function is supposed to cleanup these counters by basically removing
%% those dek types that don't use the secret anymore.
%% It asks all the nodes for deks information that they have. Then it calculates
%% what secrets are used to encrypt those deks. Then it removes all dek types
%% from the counters map that don't use the secret anymore.
-spec maybe_reset_deks_counters() ->
          ok | {error, retry | node_errors | missing_nodes}.
maybe_reset_deks_counters() ->
    AllNodes = ns_node_disco:nodes_wanted(),
    MissingNodes = AllNodes -- ns_node_disco:nodes_actual(),
    case MissingNodes of
        [] ->
            case chronicle_kv:get(kv, ?CHRONICLE_DEK_COUNTERS_KEY) of
                {ok, {OldMap, _}} when OldMap == #{} ->
                    ok;
                {ok, {OldMap, _}} ->
                    %% Each node returns information about its deks
                    %% So we can calculate which secrets are actually in use
                    %% and update that information in chronicle
                    Res = erpc:multicall(AllNodes, ?MODULE, get_node_deks_info,
                                         [], ?DEK_COUNTERS_UPDATE_TIMEOUT),
                    {NonErrors, Errors} =
                        misc:partitionmap(fun ({N, {ok, R}}) -> {left, {N, R}};
                                              ({N, E}) -> {right, {N, E}}
                                          end, lists:zip(AllNodes, Res)),
                    {SuccRes, Retries} =
                        misc:partitionmap(
                          fun ({N, retry}) -> {right, N};
                              ({_N, R}) -> {left, R}
                          end, NonErrors),
                    case {Errors, Retries} of
                        {[], []} ->
                            %% Merge results from all nodes into one map
                            DekInfo = lists:foldl(
                                        fun (M, Acc) ->
                                            maps:merge_with(fun (_, V1, V2) ->
                                                                V1 ++ V2
                                                            end, M, Acc)
                                        end, #{}, SuccRes),
                            reset_dek_counters(OldMap, DekInfo);
                        {[], _} ->
                            ?log_debug("Some nodes returned retry: ~p~n"
                                       "All responses: ~p", [Retries, Res]),
                            {error, retry};
                        {Errors, []} ->
                            ?log_error("Failed to update deks counters because "
                                       "some nodes returns errors: ~p~n"
                                       "All responses: ~p", [Errors, Res]),
                            {error, node_errors}
                    end;
                {error, not_found} ->
                    %% Nothing to update yet
                    ok
            end;
        _ ->
            ?log_debug("Skipping deks counters update because some nodes "
                       "are missing: ~p", [MissingNodes]),
            {error, missing_nodes}
    end.

-spec reset_dek_counters(
        #{EncryptionMethod := Counters},
        #{cb_deks:dek_kind() => [cb_deks:dek()]}) ->
        ok when EncryptionMethod :: {secret, secret_id()} | encryption_service,
                Counters :: #{cb_deks:dek_kind() := non_neg_integer()}.
reset_dek_counters(OldCountersMap, ActualDeksUsageInfo) ->
    Res =
        chronicle_kv:transaction(
          kv, [?CHRONICLE_SECRETS_KEY, ?CHRONICLE_DEK_COUNTERS_KEY],
          fun (Snapshot) ->
              reset_dek_counters_txn(OldCountersMap, ActualDeksUsageInfo,
                                     Snapshot)
          end),

    case Res of
        nothing_changed -> ok;
        {ok, _} -> ok
    end.

reset_dek_counters_txn(OldCountersMap, ActualDeksUsageInfo, Snapshot) ->
    KeksToSecrets = get_secret_by_kek_id_map(Snapshot),
    GetEncryptionMethod =
        fun (#{type := 'raw-aes-gcm',
               info := #{encryption_key_id := <<"encryptionService">>}}) ->
                {ok, encryption_service};
             (#{type := 'raw-aes-gcm',
               info := #{encryption_key_id := CurKekId}}) ->
                case maps:find(CurKekId, KeksToSecrets) of
                    {ok, SId} -> {ok, {secret, SId}};
                    error -> error
                end
        end,

    %% Turn #{DekKind => [Dek]} map into #{DekKind => [{secret, SecretId}]} map
    %% It represents information about which dek type uses which secret.
    SecretInfo =
        maps:map(fun (_K, Deks) ->
                     lists:filtermap(
                       fun (D) ->
                           case GetEncryptionMethod(D) of
                               {ok, Res} -> {true, Res};
                               error ->
                                   ?log_error("orphaned dek: ~p", [D]),
                                   false
                           end
                       end, Deks)
                 end, ActualDeksUsageInfo),

    DekStillUsesSecretId =
        fun (DekKind, SecretId) ->
            SecretsIdsList = maps:get(DekKind, SecretInfo, []),
            lists:member(SecretId, SecretsIdsList)
        end,

    %% Filter out those dek types that do not use that secretId anymore.
    FilterCountersForSecret =
        fun (SecretId, Map) -> %% The Map variable here represents all
                               %% dek types that still uses that secret
            maybe
                {ok, OldMap} ?= maps:find(SecretId, OldCountersMap),
                NewMap = maps:filter(
                           fun (DekKind, Counter) ->
                               DekStillUsesSecretId(DekKind, SecretId) orelse
                               %% Checking if counter has changed since before
                               %% we started deks info aggregation;
                               %% If so, that means that something started just
                               %% started using it and we should not remove it
                               %% from the map
                               (Counter /= maps:get(DekKind, OldMap, 0))
                           end, Map),
                case maps:size(NewMap) of
                    0 -> false;
                    _ -> {true, NewMap}
                end
            else
                %% This SecretId was missing in the first check, this means
                %% that something just started using that secret
                error -> true
            end
        end,

    Old = chronicle_compat:get(Snapshot,
                               ?CHRONICLE_DEK_COUNTERS_KEY,
                               #{default => #{}}),
    New = maps:filtermap(FilterCountersForSecret, Old),
    case New == Old of
        true -> {abort, nothing_changed};
        false -> {commit, [{set, ?CHRONICLE_DEK_COUNTERS_KEY, New}]}
    end.

%% Fetches a snapshot in transaction with all dek related chronicle keys,
%% and all secrets related chronicle keys.
fetch_snapshot_in_txn(Txn) ->
    BucketListSnapshot = chronicle_compat:txn_get_many(
                           [ns_bucket:root()], Txn),
    DeksRelatedSnapshot =
        lists:foldl(
          fun (Kind, Acc) ->
              L = maps:get(chronicle_txn_keys, cb_deks:dek_config(Kind)),
              New = chronicle_compat:txn_get_many(L, Txn),
              maps:merge(Acc, New)
          end,
          BucketListSnapshot,
          cb_deks:dek_kinds_list(BucketListSnapshot)),
    SecretsSnapshot = chronicle_compat:txn_get_many(
                        [?CHRONICLE_SECRETS_KEY,
                         ?CHRONICLE_DEK_COUNTERS_KEY,
                         ?CHRONICLE_NEXT_ID_KEY],
                        Txn),
    maps:merge(DeksRelatedSnapshot, SecretsSnapshot).

-spec deks_to_drop(cb_deks:dek_kind(), deks_info()) -> [cb_deks:dek_id()].
deks_to_drop(Kind, KindDeks) ->
    CurTime = calendar:universal_time(),
    NowS = calendar:datetime_to_gregorian_seconds(CurTime),
    ExpiredIds = get_expired_deks(Kind, KindDeks),
    #{deks_being_dropped := AlreadyBeingDropped,
      last_drop_timestamp := LastDropS} = KindDeks,
    DropRetryInterval = ?DEK_DROP_RETRY_TIME_S(Kind),
    LastDropTime = case LastDropS of
                       undefined -> undefined;
                       _ -> calendar:gregorian_seconds_to_datetime(LastDropS)
                   end,
    ?log_debug("The following ~p DEKs has expired: ~p~n"
               "Among them DEKs that are already being dropped: ~p~n"
               "Last drop attempt time: ~p",
               [Kind, ExpiredIds, AlreadyBeingDropped, LastDropTime]),
    %% If we have already started dropping something, we should continue
    %% even if it is not "expired" anymore.
    AllExpired = lists:usort(ExpiredIds ++ AlreadyBeingDropped),
    ToDrop =
        maybe
            #{is_enabled := true, active_id := ActiveId} ?= KindDeks,
            true ?= lists:member(ActiveId, AllExpired),
            ?log_error("Active DEK (~p) has expired for "
                       "~p (ignoring attempt to drop it)",
                       [ActiveId, Kind]),
            AllExpired -- [ActiveId]
        else
            #{is_enabled := false} -> AllExpired;
            false -> AllExpired
        end,
    ShouldAttemptDrop =
        case ToDrop -- AlreadyBeingDropped of
            [_|_] ->
                true; %% there are new deks in the list
            [] when ToDrop == [] ->
                false; %% no deks to drop
            [] when NowS > LastDropS + DropRetryInterval ->
                true; %% no new deks to drop, but it's been a while
                      %% since last drop attempt; will retry
            [] ->
                false %% no new deks to drop
        end,
    case ShouldAttemptDrop of
        true -> ToDrop;
        false -> []
    end.

-spec initiate_deks_drop(cb_deks:dek_kind(), [cb_deks:dek_id()], #state{}) ->
         #state{}.
initiate_deks_drop(Kind, IdsToDrop, #state{deks = DeksInfo} = State0) ->
    CurTime = calendar:universal_time(),
    NowS = calendar:datetime_to_gregorian_seconds(CurTime),
    #{Kind := KindDeks} = DeksInfo,
    ?log_debug("Trying to drop ~p DEKs: ~0p", [Kind, IdsToDrop]),
    case call_dek_callback(drop_callback, Kind, [IdsToDrop]) of
        {succ, {ok, Res}} ->
            NewKindDeks = KindDeks#{deks_being_dropped => IdsToDrop,
                                    last_drop_timestamp => NowS},
            State = State0#state{deks = DeksInfo#{Kind => NewKindDeks}},
            case Res of
                done ->
                    %% 'done' means that all all ids have been dropped and it is
                    %% safe to remove them
                    AllIds = [Id || #{id := Id} <- maps:get(deks, KindDeks)],
                    IdsInUse = AllIds -- IdsToDrop,
                    case retire_unused_deks(Kind, IdsInUse, State) of
                        {ok, NewState} ->
                            NewState;
                        {error, NewState, Reason} ->
                            ?log_error("Failed to retire ~p deks: ~p. "
                                       "Ignoring. Will garbage collect later",
                                       [Kind, Reason]),
                            NewState
                    end;
                started ->
                    State
            end;
        {succ, {error, not_found}} -> State0;
        {succ, {error, retry}} -> State0; %% compaction daemon not started yet
        {succ, {error, Reason}} ->
            ?log_error("drop_callback for ~p returned error: ~p",
                       [Kind, Reason]),
            State0;
        {except, _} ->
            State0
    end.

-spec validate_name_uniqueness(secret_props(), chronicle_snapshot()) ->
          ok | {error, name_not_unique}.
validate_name_uniqueness(#{id := Id, name := Name}, Snapshot) ->
    case is_name_unique(Id, Name, Snapshot) of
        true -> ok;
        false -> {error, name_not_unique}
    end.

-ifdef(TEST).
replace_secret_in_list_test() ->
    ?assertEqual(false, replace_secret_in_list(#{id => 3, p => 5}, [])),
    ?assertEqual(false,
                 replace_secret_in_list(#{id => 3, p => 5}, [#{id => 4}])),
    ?assertEqual([#{id => 4, p => 1}, #{id => 3, p => 5}, #{id => 1}],
                 replace_secret_in_list(
                   #{id => 3, p => 5},
                   [#{id => 4, p => 1}, #{id => 3, p => 6}, #{id => 1}])).

test_secret(NextTime, Interval, AutoRotation) ->
     #{type => ?GENERATED_KEY_TYPE,
       data => #{auto_rotation => AutoRotation,
                 rotation_interval_in_days => Interval,
                 next_rotation_time => NextTime}}.

calculate_next_rotation_time_test() ->
    CurTime = {{2016, 09, 30}, {16, 00, 00}},
    Secret = ?cut(test_secret(_1, 1, _2)),
    Calc = fun (List) -> calculate_next_rotation_time(CurTime, List) end,
    Min = ?MIN_RECHECK_ROTATION_INTERVAL,
    MinSec = Min div 1000,
    Max = ?MAX_RECHECK_ROTATION_INTERVAL,
    MaxSec = Max div 1000,
    Future = ?cut(misc:datetime_add(CurTime, _)),
    Past = ?cut(misc:datetime_add(CurTime, -(_))),
    ?assertEqual(Max, Calc([])),
    ?assertEqual(Min, Calc([Secret(CurTime, true)])),
    ?assertEqual(Max, Calc([Secret(CurTime, false)])),
    %% next rotation in future:
    ?assertEqual(Min, Calc([Secret(Future(MinSec - 1), true)])),
    ?assertEqual(Min + 1000, Calc([Secret(Future(MinSec + 1), true)])),
    ?assertEqual(Max, Calc([Secret(Future(MaxSec + 1), true)])),
    ?assertEqual(Max - 1000, Calc([Secret(Future(MaxSec - 1), true)])),
    %% next rotation in the past:
    ?assertEqual(Min, Calc([Secret(Past(1), true)])),
    ?assertEqual(Min, Calc([Secret(Past(?SECS_IN_DAY*5), true)])),

    ?assertEqual(Min + 11000,
                 Calc([Secret(Future(MinSec + 20), true),
                       Secret(Future(MinSec + 3),  false),
                       Secret(Future(MinSec + 12), true),
                       Secret(Future(MinSec + 11), true),
                       Secret(Past(1),             false),
                       Secret(Future(MinSec + 23), true)])).

update_next_rotation_time_test() ->
    CurTime = {{2016, 09, 30}, {16, 00, 00}},
    Calc = fun (NextTime, Interval, AutoRotation) ->
               S = test_secret(NextTime, Interval, AutoRotation),
               case update_next_rotation_time(CurTime, S) of
                   {value, #{data := #{next_rotation_time := NewDate}} = Res} ->
                       #{data := D} = S,
                       %% Making sure nothing but next_rotation_time has changed
                       ?assertEqual(
                         S#{data => D#{next_rotation_time => NewDate}}, Res),
                       NewDate;
                   false -> false
               end
           end,
    D = ?SECS_IN_DAY,
    Future = ?cut(misc:datetime_add(CurTime, _)),
    Past = ?cut(misc:datetime_add(CurTime, -(_))),

    ?assertEqual(false,             Calc(CurTime, 3, false)),
    ?assertEqual(false,             Calc(Past(1), 3, false)),
    ?assertEqual(false,             Calc(Future(1), 3, false)),
    ?assertEqual(Future(3 * D),     Calc(CurTime,   3, true)),
    ?assertEqual(false,             Calc(Future(1), 3, true)),
    ?assertEqual(Future(3 * D - 1), Calc(Past(1), 3, true)),
    ?assertEqual(Future(2 * D),     Calc(Past(D), 3, true)),
    ?assertEqual(Future(D),         Calc(Past(2 * D), 3, true)),
    ?assertEqual(Future(3 * D),     Calc(Past(3 * D), 3, true)),
    ?assertEqual(Future(3 * D - 1), Calc(Past(3 * D + 1), 3, true)),
    ?assertEqual(Future(1),         Calc(Past(3 * D - 1), 3, true)),
    ?assertEqual(Future(3 * D - 1), Calc(Past(12 * D + 1), 3, true)),
    ?assertEqual(Future(1),         Calc(Past(12 * D - 1), 3, true)).

-endif.
