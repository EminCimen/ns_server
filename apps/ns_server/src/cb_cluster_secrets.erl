%% @author Couchbase <info@couchbase.com>
%% @copyright 2024-Present Couchbase, Inc.
%%
%% Use of this software is governed by the Business Source License included in
%% the file licenses/BSL-Couchbase.txt.  As of the Change Date specified in that
%% file, in accordance with the Business Source License, use of this software
%% will be governed by the Apache License, Version 2.0, included in the file
%% licenses/APL2.txt.
%%
-module(cb_cluster_secrets).

-behaviour(gen_server).

-include("ns_common.hrl").
-include_lib("ns_common/include/cut.hrl").
-include("cb_cluster_secrets.hrl").
-ifdef(TEST).
-include_lib("eunit/include/eunit.hrl").
-endif.

%% gen_server callbacks
-export([init/1, handle_call/3, handle_cast/2, handle_info/2,
         terminate/2]).

-record(node_monitor, {}).
-record(master_monitor, {}).

%% API
-export([start_link_node_monitor/0,
         start_link_master_monitor/0,
         add_new_secret/1,
         replace_secret/2,
         get_all/0,
         get_secret/1,
         get_secret/2,
         rotate/1,
         many_to_one_result/1]).

-define(MASTER_MONITOR, {via, leader_registry, cb_cluster_secrets_master}).

-type secret_props() ::
    #{id := secret_id(),
      name := string(),
      creation_time := calendar:datetime(),
      type := secret_type(),
      usage := [{bucket_encryption, BucketName :: string()}],
      data := autogenerated_key_data() | aws_key_data()}.
-type secret_type() :: ?GENERATED_KEY_TYPE | ?AWSKMS_KEY_TYPE.
-type autogenerated_key_data() :: #{auto_rotation := boolean(),
                                    rotation_interval := pos_integer(),
                                    first_rotation_time := calendar:datetime(),
                                    active_key_id := kek_id(),
                                    keys := [kek_props()]}.
-type kek_props() :: #{id := kek_id(),
                       creation_time := calendar:datetime(),
                       key := {sensitive | encrypted_binary, binary()}}.
-type aws_key_data() :: #{key_arn := string(),
                          region := string(),
                          profile := string(),
                          config_file := string(),
                          credentials_file := string(),
                          use_imds := boolean(),
                          uuid := uuid()}.
-type secret_id() :: non_neg_integer().
-type kek_id() :: uuid().
-type chronicle_snapshot() :: direct | map().
-type uuid() :: binary(). %% uuid as binary string

%%%===================================================================
%%% API
%%%===================================================================

%% Starts on each cluster node
-spec start_link_node_monitor() -> {ok, pid()}.
start_link_node_monitor() ->
    gen_server:start_link({local, ?MODULE}, ?MODULE, [node_monitor], []).

%% Starts on the master node only
-spec start_link_master_monitor() -> {ok, pid()}.
start_link_master_monitor() ->
    misc:start_singleton(gen_server, start_link,
                         [?MASTER_MONITOR, ?MODULE, [master_monitor], []]).

-spec get_all() -> [secret_props()].
get_all() -> get_all(direct).

-spec get_all(chronicle_snapshot()) -> [secret_props()].
get_all(Snapshot) ->
    chronicle_compat:get(Snapshot, ?CHRONICLE_SECRETS_KEY, #{default => []}).

-spec get_secret(secret_id()) -> {ok, secret_props()} | {error, not_found}.
get_secret(SecretId) -> get_secret(SecretId, direct).

-spec get_secret(secret_id(), chronicle_snapshot()) ->
                                    {ok, secret_props()} | {error, not_found}.
get_secret(SecretId, Snapshot) when is_integer(SecretId) ->
    SearchFun = fun (#{id := Id}) -> SecretId == Id end,
    case lists:search(SearchFun, get_all(Snapshot)) of
        {value, Props} ->
            {ok, Props};
        false ->
            {error, not_found}
    end.

-spec add_new_secret(secret_props()) -> {ok, secret_props()} | {error, _}.
add_new_secret(Props) ->
    CurrentDateTime = erlang:universaltime(),
    PropsWTime = Props#{creation_time => CurrentDateTime},
    RV = chronicle_kv:transaction(
           kv, [?CHRONICLE_SECRETS_KEY, ?CHRONICLE_NEXT_ID_KEY],
           fun (Snapshot) ->
               CurList = get_all(Snapshot),
               NextId = chronicle_compat:get(Snapshot, ?CHRONICLE_NEXT_ID_KEY,
                                             #{default => 0}),
               PropsWId = PropsWTime#{id => NextId},
               case prepare_new_secret(PropsWId) of
                   {ok, FinalProps} ->
                       NewList = [FinalProps | CurList],
                       {commit, [{set, ?CHRONICLE_SECRETS_KEY, NewList},
                                 {set, ?CHRONICLE_NEXT_ID_KEY, NextId + 1}],
                        FinalProps};
                   {error, Reason} ->
                       {abort, {error, Reason}}
               end
            end),
    case RV of
        {ok, _, Res} -> {ok, Res};
        {error, _} = Error -> Error
    end.

-spec replace_secret(secret_props(), map()) ->
                                    {ok, secret_props()} | {error, not_found}.
replace_secret(OldProps, NewProps) ->
    Props = copy_static_props(OldProps, NewProps),
    Res =
        chronicle_kv:transaction(
          kv, [?CHRONICLE_SECRETS_KEY],
          fun (Snapshot) ->
              CurList = get_all(Snapshot),
              case replace_secret_in_list(Props, CurList) of
                  false -> %% already removed, we should not create new
                      {abort, missing};
                  NewList ->
                      {commit, [{set, ?CHRONICLE_SECRETS_KEY, NewList}]}
              end
           end),
    case Res of
        {ok, _} -> {ok, Props};
        missing -> {error, not_found}
    end.

%% Cipher should have type crypto:cipher() but it is not exported
-spec generate_raw_key(Cipher :: atom()) -> binary().
generate_raw_key(Cipher) ->
    #{key_length := Length} = crypto:cipher_info(Cipher),
    crypto:strong_rand_bytes(Length).

-spec rotate(secret_id() | string()) -> ok | {error, term()}.
rotate(Id) ->
    maybe
        {ok, #{type := ?GENERATED_KEY_TYPE} = SecretProps} ?= get_secret(Id),
        ?log_info("Rotating secret #~b", [Id]),
        {ok, NewKey} ?= generate_key(erlang:universaltime(), SecretProps),
        ok ?= add_active_key(Id, NewKey)
    else
        {ok, #{}} ->
            ?log_info("Secret #~p rotation failed: not_supported", [Id]),
            {error, not_supported};
        {error, Reason} ->
            ?log_error("Secret #~p rotation failed: ~p", [Id, Reason]),
            {error, Reason}
    end.

%% Just a helper function
-spec many_to_one_result([{T, ok} | {T, {error, R}}]) ->
                        ok | {error, [{T, R}]} when T :: term(), R :: term().
many_to_one_result(Results) ->
    Errors = lists:filtermap(fun ({T, {error, R}}) -> {true, {T, R}};
                                 ({_T, ok}) -> false
                             end, Results),
    case Errors of
        [] -> ok;
        _ -> {error, Errors}
    end.

%%%===================================================================
%%% gen_server callbacks
%%%===================================================================

init([Type]) ->
    EventFilter =
        fun (?CHRONICLE_SECRETS_KEY) -> true;
            (_Key) -> false
        end,
    Self = self(),
    chronicle_compat_events:subscribe(
      EventFilter, fun (Key) -> Self ! {config_change, Key} end),
    State = case Type of
                master_monitor ->
                    #master_monitor{};
                node_monitor ->
                    ok = maybe_reencrypt_per_node_deks(),
                    ok = ensure_all_keks_are_on_disk(),
                    #node_monitor{}
            end,
    {ok, State}.

handle_call(Request, _From, State) ->
    ?log_warning("Unhandled call: ~p", [Request]),
    {noreply, State}.

handle_cast(Msg, State) ->
    ?log_warning("Unhandled cast: ~p", [Msg]),
    {noreply, State}.

%% KEK list has updated
%% This can be creation of kek, kek rotation, historical kek removal
handle_info({config_change, ?CHRONICLE_SECRETS_KEY},
            #node_monitor{} = State) ->
    ok = ensure_all_keks_are_on_disk(),
    ok = maybe_reencrypt_per_node_deks(),
    {noreply, State};

handle_info({config_change, _}, State) ->
    {noreply, State};

handle_info(Info, State) ->
    ?log_warning("Unhandled info: ~p", [Info]),
    {noreply, State}.

terminate(_Reason, _State) ->
    ok.

%%%===================================================================
%%% Internal functions
%%%===================================================================

-spec generate_key(Creation :: calendar:datetime(), secret_props()) ->
                                            {ok, kek_props()} | {error, _}.
generate_key(CreationDateTime, SecretProps) ->
    Key = generate_raw_key(?ENVELOP_CIPHER),
    {ok, EncryptedKey} = maybe_encrypt_key(Key, SecretProps),
    {ok, #{id => misc:uuid_v4(),
           creation_time => CreationDateTime,
           key => EncryptedKey}}.

-spec set_active_key_in_props(secret_props(), kek_id()) -> secret_props().
set_active_key_in_props(#{type := ?GENERATED_KEY_TYPE,
                          data := Data} = SecretProps,
                        KeyId) ->
    SecretProps#{data => Data#{active_key_id => KeyId}}.

-spec set_keys_in_props(secret_props(), [kek_props()]) -> secret_props().
set_keys_in_props(#{type := ?GENERATED_KEY_TYPE, data := Data} = SecretProps,
                  Keys) ->
    SecretProps#{data => Data#{keys => Keys}}.

-spec copy_static_props(secret_props(), secret_props()) -> secret_props().
%% Copies properties that secret can never change
copy_static_props(#{type := Type, id := Id,
                    creation_time := CreationDT} = OldSecretProps,
                  #{type := Type} = NewSecretProps) ->
    NewSecretProps2 = NewSecretProps#{id => Id, creation_time => CreationDT},
    case NewSecretProps2 of
        #{type := ?GENERATED_KEY_TYPE} ->
            #{data := #{active_key_id := OldActiveId, keys := Keys}} =
                OldSecretProps,
            functools:chain(NewSecretProps2,
                            [set_keys_in_props(_, Keys),
                             set_active_key_in_props(_, OldActiveId)]);
        #{type := ?AWSKMS_KEY_TYPE} ->
            #{data := #{uuid := UUID}} = OldSecretProps,
            #{data := NewData} = NewSecretProps2,
            NewSecretProps2#{data => NewData#{uuid => UUID}};
        _ ->
            NewSecretProps2
    end.

-spec replace_secret_in_list(secret_props(), [secret_props()]) ->
                                                      [secret_props()] | false.
replace_secret_in_list(NewProps, List) ->
    Id = maps:get(id, NewProps),
    ReplaceFun = fun Replace([], _Acc) -> false;
                     Replace([Next | Rest], Acc) ->
                         case maps:get(id, Next) of
                             Id -> lists:reverse([NewProps | Acc], Rest);
                             _ -> Replace(Rest, [Next | Acc])
                         end
                 end,
    ReplaceFun(List, []).

-spec add_active_key(secret_id(), kek_props()) -> ok | {error, not_found}.
add_active_key(Id, #{id := KekId} = Kek) ->
    RV = chronicle_kv:transaction(
           kv, [?CHRONICLE_SECRETS_KEY],
           fun (Snapshot) ->
               case get_secret(Id, Snapshot) of
                   {ok, #{type := ?GENERATED_KEY_TYPE,
                          data := #{keys := CurKeks}} = SecretProps} ->
                       Updated = functools:chain(
                                   SecretProps,
                                   [set_keys_in_props(_, [Kek | CurKeks]),
                                    set_active_key_in_props(_, KekId)]),
                       NewList = replace_secret_in_list(Updated,
                                                        get_all(Snapshot)),
                       true = is_list(NewList),
                       {commit, [{set, ?CHRONICLE_SECRETS_KEY, NewList}]};
                   {error, not_found} ->
                       {abort, not_found}
               end
           end),

    case RV of
        {ok, _} -> ok;
        not_found -> {error, not_found}
    end.

-spec ensure_all_keks_are_on_disk() -> ok | {error, list()}.
ensure_all_keks_are_on_disk() ->
    RV = lists:map(fun (#{id := Id,
                          type := ?GENERATED_KEY_TYPE} = SecretProps)  ->
                           {Id, ensure_generated_keks_on_disk(SecretProps)};
                       (#{id := Id, type := ?AWSKMS_KEY_TYPE} = SecretProps) ->
                           {Id, ensure_aws_kek_on_disk(SecretProps)};
                       (#{id := Id}) ->
                           {Id, ok}
                   end, get_all()),
    many_to_one_result(RV).

-spec ensure_generated_keks_on_disk(secret_props()) -> ok | {error, list()}.
ensure_generated_keks_on_disk(#{type := ?GENERATED_KEY_TYPE, id := SecretId,
                                data := #{keys := Keys}}) ->
    ?log_debug("Ensure all keys are on disk for secret ~p "
               "(number of keys to check: ~b)", [SecretId, length(Keys)]),
    Res = lists:map(fun (#{id := Id} = K) ->
                        {Id, ensure_kek_on_disk(K)}
                    end, Keys),
    many_to_one_result(Res).

-spec ensure_kek_on_disk(kek_props()) -> ok | {error, _}.
ensure_kek_on_disk(#{id := Id, key := {sensitive, Key}}) ->
    encryption_service:store_kek(Id, Key).

-spec ensure_aws_kek_on_disk(secret_props()) -> ok | {error, _}.
ensure_aws_kek_on_disk(#{data := Data}) ->
    #{uuid := UUID, key_arn := KeyArn, region := Region, profile := Profile,
      config_file := ConfigFile, credentials_file := CredsFile,
      use_imds := UseIMDS} = Data,
    encryption_service:store_awskey(UUID, KeyArn, Region, Profile,
                                    CredsFile, ConfigFile, UseIMDS).

-spec maybe_encrypt_key(binary(), secret_props()) ->
                           {ok, {sensitive, binary()}} | {error, _}.
maybe_encrypt_key(Key, #{type := ?GENERATED_KEY_TYPE}) ->
    %% Relying on SM to encrypt it automatically
    {ok, {sensitive, Key}}.

-spec prepare_new_secret(secret_props()) -> {ok, secret_props()} | {error, _}.
prepare_new_secret(#{type := ?GENERATED_KEY_TYPE,
                     creation_time := CurrentTime} = Props) ->
    maybe
        %% Creating new auto-generated key
        {ok, #{id := KekId} = KeyProps} ?= generate_key(CurrentTime,  Props),
        {ok, functools:chain(Props, [set_keys_in_props(_, [KeyProps]),
                                     set_active_key_in_props(_, KekId)])}
    else
        {error, _} = Error -> Error
    end;
prepare_new_secret(#{type := ?AWSKMS_KEY_TYPE, data := Data} = Props) ->
    {ok, Props#{data => Data#{uuid => misc:uuid_v4()}}};
prepare_new_secret(#{type := _Type}) ->
    {error, not_supported}.

-spec maybe_reencrypt_per_node_deks() -> ok.
maybe_reencrypt_per_node_deks() ->
    %% TODO
    ok.

-ifdef(TEST).
replace_secret_in_list_test() ->
    ?assertEqual(false, replace_secret_in_list(#{id => 3, p => 5}, [])),
    ?assertEqual(false,
                 replace_secret_in_list(#{id => 3, p => 5}, [#{id => 4}])),
    ?assertEqual([#{id => 4, p => 1}, #{id => 3, p => 5}, #{id => 1}],
                 replace_secret_in_list(
                   #{id => 3, p => 5},
                   [#{id => 4, p => 1}, #{id => 3, p => 6}, #{id => 1}])).
-endif.
